From d261ba87bdf1cc3c87abaa78f582983ba4ad9c44 Mon Sep 17 00:00:00 2001
From: Sultan Alsawaf <sultan@kerneltoast.com>
Date: Sat, 27 May 2023 14:57:21 -0700
Subject: [PATCH] selinux: Avoid dynamic memory allocation for temporary
 scontext buffers

Common sizes for the scontext buffers are small enough to fit on the stack,
saving two dynamic memory allocations from this hot path.

Change-Id: I9bace557c9ed55cee5c27a29cde4d2c897242c96
Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>
Signed-off-by: Richard Raya <rdxzv.dev@gmail.com>
---
 security/selinux/ss/services.c | 40 +++++++++++++++++++++++++---------
 1 file changed, 30 insertions(+), 10 deletions(-)

diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.c
index e5d143145c0a7..86058079d46ff 100644
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@ -1503,6 +1503,8 @@ static int security_context_to_sid_core(const char *scontext, u32 scontext_len,
 	struct selinux_policy *policy;
 	struct policydb *policydb;
 	struct sidtab *sidtab;
+	char scontext2_onstack[SZ_128] __aligned(sizeof(long));
+	char str_onstack[SZ_128] __aligned(sizeof(long));
 	char *scontext2, *str = NULL;
 	struct context context;
 	int rc = 0;
@@ -1512,9 +1514,15 @@ static int security_context_to_sid_core(const char *scontext, u32 scontext_len,
 		return -EINVAL;
 
 	/* Copy the string to allow changes and ensure a NUL terminator */
-	scontext2 = kmemdup_nul(scontext, scontext_len, gfp_flags);
-	if (!scontext2)
-		return -ENOMEM;
+	if (scontext_len < sizeof(scontext2_onstack)) {
+		scontext2 = scontext2_onstack;
+		memcpy(scontext2, scontext, scontext_len);
+		scontext2[scontext_len] = '\0';
+	} else {
+		scontext2 = kmemdup_nul(scontext, scontext_len, gfp_flags);
+		if (!scontext2)
+			return -ENOMEM;
+	}
 
	if (!selinux_initialized(state)) {
		int i;
@@ -1534,10 +1542,16 @@ static int security_context_to_sid_core(const char *scontext, u32 scontext_len,
 
 	if (force) {
 		/* Save another copy for storing in uninterpreted form */
-		rc = -ENOMEM;
-		str = kstrdup(scontext2, gfp_flags);
-		if (!str)
-			goto out;
+		if (scontext2 == scontext2_onstack) {
+			str = str_onstack;
+			memcpy(str, scontext2, scontext_len + 1);
+		} else {
+			str = kstrdup(scontext2, gfp_flags);
+			if (!str) {
+				rc = -ENOMEM;
+				goto out;
+			}
+		}
 	}
 retry:
 	rcu_read_lock();
@@ -1548,11 +1562,15 @@ static int security_context_to_sid_core(const char *scontext, u32 scontext_len,
 				      &context, def_sid);
 	if (rc == -EINVAL && force) {
 		context.str = str;
-		context.len = strlen(str) + 1;
+		context.len = scontext_len + 1;
 		str = NULL;
 	} else if (rc)
 		goto out_unlock;
 	rc = sidtab_context_to_sid(sidtab, &context, sid);
+
+	if (context.str == str_onstack)
+		context.str = NULL;
+
 	if (rc == -ESTALE) {
 		rcu_read_unlock();
 		if (context.str) {
@@ -1566,8 +1584,10 @@ static int security_context_to_sid_core(const char *scontext, u32 scontext_len,
 out_unlock:
 	rcu_read_unlock();
 out:
-	kfree(scontext2);
-	kfree(str);
+	if (scontext2 != scontext2_onstack) {
+		kfree(scontext2);
+		kfree(str);
+	}
 	return rc;
 }
 
