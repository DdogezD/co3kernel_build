From 5e4c7ef7b489ae5cd6bdf6bec6e304694f218022 Mon Sep 17 00:00:00 2001
From: yuedl1 <yuedl1@lenovo.com>
Date: Tue, 20 Sep 2022 21:20:53 +0800
Subject: [PATCH] scsi/ufs: Porting samsung ufs HID feature driver

samsung ufs support HID feature and s-hid feature on 8550, so prot
samsung's ufs hid and s-hid driver. this drvier is from samsung .

Change-Id: Ifef382d84139d1ee1e20df1ca63df26a7f71d099
Signed-off-by: yuedl1 <yuedl1@lenovo.com>
Reviewed-on: https://gerrit.mot.com/2387409
SME-Granted: SME Approvals Granted
SLTApproved: Slta Waiver
Tested-by: Jira Key
Reviewed-by: Chuanchun Zhu <zhucc2@motorola.com>
Reviewed-by: Zhenxin Xi <xizx@motorola.com>
Submit-Approved: Jira Key
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 drivers/scsi/ufs/Kconfig                   |   35 +
 drivers/scsi/ufs/Makefile                  |    5 +
 drivers/scsi/ufs/ufs-qcom.c                |  118 ++-
 drivers/scsi/ufs/ufs-qcom.h                |   16 +
 drivers/scsi/ufs/vendor/ufsfeature-mimic.c |  135 +++
 drivers/scsi/ufs/vendor/ufsfeature.c       |  614 +++++++++++
 drivers/scsi/ufs/vendor/ufsfeature.h       |  217 ++++
 drivers/scsi/ufs/vendor/ufshid.c           | 1088 ++++++++++++++++++++
 drivers/scsi/ufs/vendor/ufshid.h           |  161 +++
 drivers/scsi/ufs/vendor/ufssid.c           |  292 ++++++
 drivers/scsi/ufs/vendor/ufssid.h           |   69 ++
 11 files changed, 2748 insertions(+), 2 deletions(-)
 create mode 100644 drivers/scsi/ufs/vendor/ufsfeature-mimic.c
 create mode 100644 drivers/scsi/ufs/vendor/ufsfeature.c
 create mode 100644 drivers/scsi/ufs/vendor/ufsfeature.h
 create mode 100644 drivers/scsi/ufs/vendor/ufshid.c
 create mode 100644 drivers/scsi/ufs/vendor/ufshid.h
 create mode 100644 drivers/scsi/ufs/vendor/ufssid.c
 create mode 100644 drivers/scsi/ufs/vendor/ufssid.h

diff --git a/drivers/scsi/ufs/Kconfig b/drivers/scsi/ufs/Kconfig
index a7da12af10e2d..df4699d7437a2 100644
--- a/drivers/scsi/ufs/Kconfig
+++ b/drivers/scsi/ufs/Kconfig
@@ -228,3 +228,38 @@ config SCSI_UFS_HWMON
 	  a hardware monitoring device will be created for the UFS device.
 
 	  If unsure, say N.
+
+config UFSFEATURE
+	bool "UFS feature activate"
+	depends on SCSI_UFSHCD
+	help
+	  UFS feature activate such as hpb, tw and etc.
+
+config UFSHID
+	bool "UFS Host Initiated Defrag support"
+	depends on SCSI_UFSHCD && UFSFEATURE
+	help
+	  UFS HID Feature Enable
+
+config UFSHID_POC
+	bool "UFSHID_POC test"
+	depends on SCSI_UFSHCD && UFSFEATURE && UFSHID
+	help
+	  UFS HID POC test
+	  1. block to enter suspend state
+	  2. auto_hibern8 enable/disable (HCI)
+	  3. set flag bDefragOperation
+	  4. debug msg enable (default : disable)
+
+config UFSHID_DEBUG
+	bool "HID Debug Enable"
+	depends on SCSI_UFSHCD && UFSFEATURE && UFSHID
+	default n
+	help
+	UFS HID Debug Enable (for check io stat during trigger)
+
+config UFSSID
+	bool "UFS Stream ID support"
+	depends on SCSI_UFSHCD && UFSFEATURE && UFSHID
+	help
+	  Enable Stream ID Feature for Streamed-HID
diff --git a/drivers/scsi/ufs/Makefile b/drivers/scsi/ufs/Makefile
index 94291f1e57699..d0b08ceb26ea5 100644
--- a/drivers/scsi/ufs/Makefile
+++ b/drivers/scsi/ufs/Makefile
@@ -3,6 +3,8 @@
 
 # The link order is important here. ufshcd-core must initialize
 # before vendor drivers.
+ccflags-y += -I$(srctree)/drivers/scsi/ufs/vendor
+
 obj-$(CONFIG_SCSI_UFSHCD)		+= ufshcd-core.o
 ufshcd-core-y				+= ufshcd.o ufs-sysfs.o
 ufshcd-core-$(CONFIG_DEBUG_FS)		+= ufs-debugfs.o
@@ -17,6 +19,9 @@ obj-$(CONFIG_SCSI_UFS_DWC_TC_PLATFORM) += tc-dwc-g210-pltfrm.o ufshcd-dwc.o tc-d
 obj-$(CONFIG_SCSI_UFS_CDNS_PLATFORM) += cdns-pltfrm.o
 obj-$(CONFIG_SCSI_UFS_QCOM) += ufs_qcom.o
 ufs_qcom-y += ufs-qcom.o
+ufs_qcom-$(CONFIG_UFSFEATURE) += vendor/ufsfeature.o vendor/ufsfeature-mimic.o
+ufs_qcom-$(CONFIG_UFSHID) += vendor/ufshid.o
+ufs_qcom-$(CONFIG_UFSSID) += vendor/ufssid.o
 ufs_qcom-$(CONFIG_SCSI_UFS_CRYPTO) += ufs-qcom-ice.o
 obj-$(CONFIG_SCSI_UFS_EXYNOS) += ufs-exynos.o
 obj-$(CONFIG_SCSI_UFSHCD_PCI) += ufshcd-pci.o
diff --git a/drivers/scsi/ufs/ufs-qcom.c b/drivers/scsi/ufs/ufs-qcom.c
index 8106e1416ffb0..8b4e247e0e814 100644
--- a/drivers/scsi/ufs/ufs-qcom.c
+++ b/drivers/scsi/ufs/ufs-qcom.c
@@ -467,6 +467,68 @@ static int ufs_qcom_get_pwr_dev_param(struct ufs_qcom_dev_params *qcom_param,
 	return 0;
 }
 
+#if defined(CONFIG_UFSFEATURE)
+static void ufs_vh_prep_fn(void *data, struct ufs_hba *hba,
+			struct request *rq, struct ufshcd_lrb *lrbp, int *err)
+{
+	ufsf_change_lun(ufs_qcom_get_ufsf(hba), lrbp);
+	*err = ufsf_prep_fn(ufs_qcom_get_ufsf(hba), lrbp);
+}
+
+static void ufs_vh_compl_command(void *data, struct ufs_hba *hba,
+				 struct ufshcd_lrb *lrbp)
+{
+	struct utp_upiu_header *header = &lrbp->ucd_rsp_ptr->header;
+	struct ufsf_feature *ufsf = ufs_qcom_get_ufsf(hba);
+	struct scsi_cmnd *cmd = lrbp->cmd;
+	int scsi_status, result, ocs;
+
+	if (!cmd)
+		return;
+
+	ocs = le32_to_cpu(lrbp->utr_descriptor_ptr->header.dword_2) & MASK_OCS;
+	if (ocs != OCS_SUCCESS)
+		goto check_last_req;
+
+	result = be32_to_cpu(header->dword_0) >> 24;
+	if (result != UPIU_TRANSACTION_RESPONSE)
+		goto check_last_req;
+
+	scsi_status = be32_to_cpu(header->dword_1) & MASK_SCSI_STATUS;
+	if (scsi_status != SAM_STAT_GOOD)
+		goto check_last_req;
+
+	ufsf_upiu_check_for_ccd(lrbp);
+
+check_last_req:
+#if defined(CONFIG_UFSHID)
+	/* Check if it is the last request to be completed */
+	if (hba->outstanding_tasks ||
+	    !(hba->outstanding_reqs == (1 << lrbp->task_tag)))
+		return;
+
+	schedule_work(&ufsf->on_idle_work);
+#endif
+	;
+}
+
+static void ufs_vh_update_sdev(void *data, struct scsi_device *sdev)
+{
+	struct ufs_hba *hba = shost_priv(sdev->host);
+	struct ufsf_feature *ufsf = ufs_qcom_get_ufsf(hba);
+
+	ufsf_slave_configure(ufsf, sdev);
+}
+
+static void ufs_vh_send_command(void *data, struct ufs_hba *hba,
+				struct ufshcd_lrb *lrbp)
+{
+	struct ufsf_feature *ufsf = ufs_qcom_get_ufsf(hba);
+
+	ufsf_hid_acc_io_stat(ufsf, lrbp);
+}
+#endif
+
 static struct ufs_qcom_host *rcdev_to_ufs_host(struct reset_controller_dev *rcd)
 {
 	return container_of(rcd, struct ufs_qcom_host, rcdev);
@@ -1485,8 +1547,12 @@ static int ufs_qcom_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op,
 	struct ufs_qcom_host *host = ufshcd_get_variant(hba);
 	int err = 0;
 
-	if (status == PRE_CHANGE)
+	if (status == PRE_CHANGE) {
+#if defined(CONFIG_UFSFEATURE)
+		ufsf_suspend(ufs_qcom_get_ufsf(hba));
+#endif
 		return 0;
+	}
 
 	/*
 	 * If UniPro link is not active or OFF, PHY ref_clk, main PHY analog
@@ -1531,6 +1597,11 @@ static int ufs_qcom_resume(struct ufs_hba *hba, enum ufs_pm_op pm_op)
 {
 	struct ufs_qcom_host *host = ufshcd_get_variant(hba);
 	int err;
+#if defined(CONFIG_UFSFEATURE)
+	struct ufsf_feature *ufsf = ufs_qcom_get_ufsf(hba);
+
+	schedule_work(&ufsf->resume_work);
+#endif
 
 	if (host->vddp_ref_clk && (hba->rpm_lvl > UFS_PM_LVL_3 ||
 				   hba->spm_lvl > UFS_PM_LVL_3))
@@ -1923,6 +1994,15 @@ static int ufs_qcom_bus_register(struct ufs_qcom_host *host)
 	return 0;
 }
 
+static void ufs_qcom_event_notify(struct ufs_hba *hba, enum ufs_event_type evt,
+				  void *data)
+{
+#if defined(CONFIG_UFSFEATURE)
+	if (evt == UFS_EVT_WL_SUSP_ERR)
+		ufsf_resume(ufs_qcom_get_ufsf(hba), true);
+#endif
+}
+
 static void ufs_qcom_dev_ref_clk_ctrl(struct ufs_qcom_host *host, bool enable)
 {
 	if (host->dev_ref_clk_ctrl_mmio &&
@@ -3654,6 +3734,17 @@ static int ufs_qcom_init(struct ufs_hba *hba)
 			ufs_qcom_msg(WARN, dev, "Fail to register UFS panic notifier\n");
 	}
 
+	/* Provide SCSI host ioctl API */
+	hba->host->hostt->ioctl = (int (*)(struct scsi_device *, unsigned int,
+				   void __user *))ufs_qcom_ioctl;
+#ifdef CONFIG_COMPAT
+	hba->host->hostt->compat_ioctl = (int (*)(struct scsi_device *,
+					  unsigned int,
+					  void __user *))ufs_qcom_ioctl;
+#endif
+#if defined(CONFIG_UFSFEATURE)
+	ufsf_set_init_state(hba);
+#endif
 	goto out;
 
 out_disable_vccq_parent:
@@ -4481,6 +4572,10 @@ static int ufs_qcom_device_reset(struct ufs_hba *hba)
 		ufs_qcom_msg(WARN, hba->dev, "%s: host reset returned %d\n",
 				 __func__, ret);
 
+#if defined(CONFIG_UFSFEATURE)
+	ufsf_reset_host(ufs_qcom_get_ufsf(hba));
+#endif
+
 	/* reset gpio is optional */
 	if (!host->device_reset)
 		return -EOPNOTSUPP;
@@ -4568,6 +4663,9 @@ static const struct ufs_hba_variant_ops ufs_hba_qcom_vops = {
 	.config_scaling_param = ufs_qcom_config_scaling_param,
 	.program_key		= ufs_qcom_ice_program_key,
 	.fixup_dev_quirks       = ufs_qcom_fixup_dev_quirks,
+#if defined(CONFIG_UFSFEATURE)
+	.event_notify		= ufs_qcom_event_notify,
+#endif
 };
 
 /**
@@ -4894,6 +4992,10 @@ static void ufs_qcom_hook_send_command(void *param, struct ufs_hba *hba,
 {
 	struct ufs_qcom_host *host = ufshcd_get_variant(hba);
 
+#if defined(CONFIG_UFSFEATURE)
+	ufs_vh_send_command(param, hba, lrbp);
+#endif
+
 	if (lrbp && lrbp->cmd && lrbp->cmd->cmnd[0]) {
 		struct request *rq = scsi_cmd_to_rq(lrbp->cmd);
 		int sz = rq ? blk_rq_sectors(rq) : 0;
@@ -4918,7 +5020,9 @@ static void ufs_qcom_hook_compl_command(void *param, struct ufs_hba *hba,
 {
 
 	struct ufs_qcom_host *host = ufshcd_get_variant(hba);
-
+#if defined(CONFIG_UFSFEATURE)
+    ufs_vh_compl_command(param, hba, lrbp);
+#endif
 	if (lrbp && lrbp->cmd) {
 		int sz = scsi_cmd_to_rq(lrbp->cmd) ?
 				blk_rq_sectors(scsi_cmd_to_rq(lrbp->cmd)) : 0;
@@ -4991,6 +5095,9 @@ static void ufs_qcom_hook_check_int_errors(void *param, struct ufs_hba *hba,
 
 static void ufs_qcom_update_sdev(void *param, struct scsi_device *sdev)
 {
+#if defined(CONFIG_UFSFEATURE)
+	ufs_vh_update_sdev(param, sdev);
+#endif
 	sdev->broken_fua = 1;
 }
 
@@ -5023,6 +5130,9 @@ static void ufs_qcom_hook_prepare_command(void *param, struct ufs_hba *hba,
  */
 static void ufs_qcom_register_hooks(void)
 {
+#if defined(CONFIG_UFSFEATURE)
+	register_trace_android_vh_ufs_prepare_command(ufs_vh_prep_fn, NULL);
+#endif
 	register_trace_android_vh_ufs_send_command(ufs_qcom_hook_send_command,
 						NULL);
 	register_trace_android_vh_ufs_compl_command(
@@ -5172,6 +5282,10 @@ static int ufs_qcom_remove(struct platform_device *pdev)
 
 	pm_runtime_get_sync(&(pdev)->dev);
 
+#if defined(CONFIG_UFSFEATURE)
+	ufsf_remove(ufs_qcom_get_ufsf(hba));
+#endif
+
 	ufshcd_remove(hba);
 	return 0;
 }
diff --git a/drivers/scsi/ufs/ufs-qcom.h b/drivers/scsi/ufs/ufs-qcom.h
index a4829e9090180..cc81a0be6c554 100644
--- a/drivers/scsi/ufs/ufs-qcom.h
+++ b/drivers/scsi/ufs/ufs-qcom.h
@@ -13,6 +13,9 @@
 #include <linux/panic_notifier.h>
 #include "ufshcd.h"
 #include "unipro.h"
+#ifdef CONFIG_UFSFEATURE
+#include "ufsfeature.h"
+#endif
 
 #define MAX_UFS_QCOM_HOSTS	2
 #define MAX_U32                 (~(u32)0)
@@ -528,6 +531,10 @@ struct ufs_qcom_host {
 
 	struct gpio_desc *device_reset;
 
+#if defined(CONFIG_UFSFEATURE)
+	struct ufsf_feature ufsf;
+#endif
+
 	int max_hs_gear;
 	int limit_tx_hs_gear;
 	int limit_rx_hs_gear;
@@ -581,6 +588,15 @@ struct ufs_qcom_host {
 
 };
 
+#if defined(CONFIG_UFSFEATURE)
+static inline struct ufsf_feature *ufs_qcom_get_ufsf(struct ufs_hba *hba)
+{
+	struct ufs_qcom_host *host = ufshcd_get_variant(hba);
+
+	return &host->ufsf;
+}
+#endif
+
 static inline u32
 ufs_qcom_get_debug_reg_offset(struct ufs_qcom_host *host, u32 reg)
 {
diff --git a/drivers/scsi/ufs/vendor/ufsfeature-mimic.c b/drivers/scsi/ufs/vendor/ufsfeature-mimic.c
new file mode 100644
index 0000000000000..13285e4e27930
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufsfeature-mimic.c
@@ -0,0 +1,135 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Samsung UFS Feature Mimic for android12-5.10
+ * commit e41c9937238f52c66c07cbcb3a0ea5ed6de152df
+ * Date:   Tue Aug 10 10:18:01 2021 -0700
+ *
+ * Copyright (C) 2021 Samsung Electronics Co., Ltd.
+ *
+ * Author:
+ *	Keoseong Park <keosung.park@samsung.com>
+ *
+ * from
+ *
+ * linux/drivers/scsi/ufs/ufshcd.c
+ */
+
+#include "ufshcd.h"
+#include "ufshcd-crypto.h"
+#include "ufs-qcom.h"
+#include "ufsfeature.h"
+#include <trace/events/ufs.h>
+#include <trace/hooks/ufshcd.h>
+
+/* Query request retries */
+#define QUERY_REQ_RETRIES 3
+/* Query request timeout */
+#define QUERY_REQ_TIMEOUT 1500 /* 1.5 seconds */
+/* Task management command timeout */
+#define TM_CMD_TIMEOUT	100 /* msecs */
+
+/**
+ * ufsf_wait_for_register - wait for register value to change
+ * @hba: per-adapter interface
+ * @reg: mmio register offset
+ * @mask: mask to apply to the read register value
+ * @val: value to wait for
+ * @interval_us: polling interval in microseconds
+ * @timeout_ms: timeout in milliseconds
+ *
+ * Return:
+ * -ETIMEDOUT on error, zero on success.
+ */
+int ufsf_wait_for_register(struct ufs_hba *hba, u32 reg, u32 mask,
+			   u32 val, unsigned long interval_us,
+			   unsigned long timeout_ms)
+{
+	int err = 0;
+	unsigned long timeout = jiffies + msecs_to_jiffies(timeout_ms);
+
+	/* ignore bits that we don't intend to wait on */
+	val = val & mask;
+
+	while ((ufshcd_readl(hba, reg) & mask) != val) {
+		usleep_range(interval_us, interval_us + 50);
+		if (time_after(jiffies, timeout)) {
+			if ((ufshcd_readl(hba, reg) & mask) != val)
+				err = -ETIMEDOUT;
+			break;
+		}
+	}
+
+	return err;
+}
+
+void ufsf_scsi_unblock_requests(struct ufs_hba *hba)
+{
+	if (atomic_dec_and_test(&hba->scsi_block_reqs_cnt))
+		scsi_unblock_requests(hba->host);
+}
+
+void ufsf_scsi_block_requests(struct ufs_hba *hba)
+{
+	if (atomic_inc_return(&hba->scsi_block_reqs_cnt) == 1)
+		scsi_block_requests(hba->host);
+}
+
+int ufsf_wait_for_doorbell_clr(struct ufs_hba *hba, u64 wait_timeout_us)
+{
+	unsigned long flags;
+	int ret = 0;
+	u32 tm_doorbell;
+	u32 tr_doorbell;
+	bool timeout = false, do_last_check = false;
+	ktime_t start;
+
+	ufshcd_hold(hba, false);
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	/*
+	 * Wait for all the outstanding tasks/transfer requests.
+	 * Verify by checking the doorbell registers are clear.
+	 */
+	start = ktime_get();
+	do {
+		if (hba->ufshcd_state != UFSHCD_STATE_OPERATIONAL) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		tm_doorbell = ufshcd_readl(hba, REG_UTP_TASK_REQ_DOOR_BELL);
+		tr_doorbell = ufshcd_readl(hba, REG_UTP_TRANSFER_REQ_DOOR_BELL);
+		if (!tm_doorbell && !tr_doorbell) {
+			timeout = false;
+			break;
+		} else if (do_last_check) {
+			break;
+		}
+
+		spin_unlock_irqrestore(hba->host->host_lock, flags);
+		schedule();
+		if (ktime_to_us(ktime_sub(ktime_get(), start)) >
+		    wait_timeout_us) {
+			timeout = true;
+			/*
+			 * We might have scheduled out for long time so make
+			 * sure to check if doorbells are cleared by this time
+			 * or not.
+			 */
+			do_last_check = true;
+		}
+		spin_lock_irqsave(hba->host->host_lock, flags);
+	} while (tm_doorbell || tr_doorbell);
+
+	if (timeout) {
+		dev_err(hba->dev,
+			"%s: timedout waiting for doorbell to clear (tm=0x%x, tr=0x%x)\n",
+			__func__, tm_doorbell, tr_doorbell);
+		ret = -EBUSY;
+	}
+out:
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+	ufshcd_release(hba);
+	return ret;
+}
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/scsi/ufs/vendor/ufsfeature.c b/drivers/scsi/ufs/vendor/ufsfeature.c
new file mode 100644
index 0000000000000..c2405720ce413
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufsfeature.c
@@ -0,0 +1,614 @@
+/*
+ * Universal Flash Storage Feature Support
+ *
+ * Copyright (C) 2017-2018 Samsung Electronics Co., Ltd.
+ *
+ * Authors:
+ *	Yongmyung Lee <ymhungry.lee@samsung.com>
+ *	Jinyoung Choi <j-young.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ *
+ * The Linux Foundation chooses to take subject only to the GPLv2
+ * license terms, and distributes only under these terms.
+ */
+
+#include "ufsfeature.h"
+#include "ufshcd.h"
+#include "ufs-qcom.h"
+
+static int ufsf_read_desc(struct ufs_hba *hba, u8 desc_id, u8 desc_index,
+			  u8 *desc_buf, u32 size)
+{
+	int err = 0;
+
+	pm_runtime_get_sync(hba->dev);
+
+	err = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_READ_DESC,
+					    desc_id, desc_index, 0,
+					    desc_buf, &size);
+	if (err)
+		ERR_MSG("reading Device Desc failed. err = %d", err);
+
+	pm_runtime_put_sync(hba->dev);
+
+	return err;
+}
+
+static int ufsf_read_dev_desc(struct ufsf_feature *ufsf)
+{
+	u8 desc_buf[UFSF_QUERY_DESC_DEVICE_MAX_SIZE];
+	int ret;
+
+	ret = ufsf_read_desc(ufsf->hba, UFSF_QUERY_DESC_IDN_DEVICE, 0,
+			     desc_buf, UFSF_QUERY_DESC_DEVICE_MAX_SIZE);
+
+	if (ret)
+		return ret;
+
+	ufsf->num_lu = desc_buf[DEVICE_DESC_PARAM_NUM_LU];
+	INFO_MSG("device lu count %d", ufsf->num_lu);
+
+	INFO_MSG("length=%u(0x%x) bSupport=0x%.2x, extend=0x%.2x_%.2x",
+		  desc_buf[DEVICE_DESC_PARAM_LEN],
+		  desc_buf[DEVICE_DESC_PARAM_LEN],
+		  desc_buf[DEVICE_DESC_PARAM_UFS_FEAT],
+		  desc_buf[DEVICE_DESC_PARAM_EX_FEAT_SUP+2],
+		  desc_buf[DEVICE_DESC_PARAM_EX_FEAT_SUP+3]);
+
+	INFO_MSG("samsung extend=0x%.2x_%.2x",
+		  desc_buf[DEVICE_DESC_PARAM_SAMSUNG_SUP+2],
+		  desc_buf[DEVICE_DESC_PARAM_SAMSUNG_SUP+3]);
+
+	INFO_MSG("Driver Feature Version : (%.6X%s)", UFSFEATURE_DD_VER,
+		 UFSFEATURE_DD_VER_POST);
+
+#if defined(CONFIG_UFSHID)
+	ufshid_get_dev_info(ufsf, desc_buf);
+#endif
+#if defined(CONFIG_UFSSID)
+	ufssid_get_dev_info(ufsf, desc_buf);
+#endif
+	return 0;
+}
+
+void ufsf_device_check(struct ufs_hba *hba)
+{
+	struct ufsf_feature *ufsf = ufs_qcom_get_ufsf(hba);
+
+	ufsf_read_dev_desc(ufsf);
+}
+
+static int ufsf_execute_dev_ctx_req(struct ufsf_feature *ufsf,
+				    int lun, unsigned char *cdb,
+				    void *buf, int len)
+{
+	struct scsi_sense_hdr sshdr;
+	struct scsi_device *sdev;
+	int ret;
+
+	sdev = ufsf->sdev_ufs_lu[lun];
+	if (!sdev) {
+		WARN_MSG("cannot find scsi_device");
+		return -ENODEV;
+	}
+
+	ufsf->issue_ioctl = true;
+	ret = scsi_execute(sdev, cdb, DMA_FROM_DEVICE, buf, len, NULL, &sshdr,
+			   msecs_to_jiffies(30000), 3, 0, 0, NULL);
+	ufsf->issue_ioctl = false;
+
+	return ret;
+}
+
+static inline void ufsf_set_read_dev_ctx(unsigned char *cdb, int lba, int len)
+{
+	cdb[0] = READ_10;
+	cdb[1] = 0x02;
+	put_unaligned_be32(lba, cdb + 2);
+	put_unaligned_be24(len, cdb + 6);
+}
+
+static int ufsf_issue_req_dev_ctx(struct ufsf_feature *ufsf, int lun,
+				  unsigned char *buf, int buf_len)
+{
+	unsigned char cdb[10] = { 0 };
+	int cmd_len = buf_len >> OS_PAGE_SHIFT;
+	int ret;
+
+	ufsf_set_read_dev_ctx(cdb, READ10_DEBUG_LBA, cmd_len);
+
+	ret = ufsf_execute_dev_ctx_req(ufsf, lun, cdb, buf, buf_len);
+
+	if (ret < 0)
+		ERR_MSG("failed with err %d", ret);
+
+	return ret;
+}
+
+static void ufsf_print_query_buf(unsigned char *field, int size)
+{
+	unsigned char buf[255];
+	int count;
+	int i;
+
+	count = snprintf(buf, 8, "(0x00):");
+
+	for (i = 0; i < size; i++) {
+		count += snprintf(buf + count, 4, " %.2X", field[i]);
+
+		if ((i + 1) % 16 == 0) {
+			buf[count] = '\n';
+			buf[count + 1] = '\0';
+			printk(buf);
+			count = 0;
+			count += snprintf(buf, 8, "(0x%.2X):", i + 1);
+		} else if ((i + 1) % 4 == 0)
+			count += snprintf(buf + count, 3, " :");
+	}
+	buf[count] = '\n';
+	buf[count + 1] = '\0';
+	printk(buf);
+}
+
+static inline void ufsf_set_read10_debug_cmd(unsigned char *cdb, int lba,
+					     int len)
+{
+	cdb[0] = READ_10;
+	cdb[1] = 0x02;
+	put_unaligned_be32(lba, cdb + 2);
+	put_unaligned_be24(len, cdb + 6);
+}
+
+int ufsf_query_ioctl(struct ufsf_feature *ufsf, int lun, void __user *buffer,
+		     struct ufs_ioctl_query_data *ioctl_data)
+{
+	unsigned char *kernel_buf;
+	int opcode;
+	int err = 0;
+	int index = 0;
+	int length = 0;
+	int buf_len = 0;
+
+	opcode = ioctl_data->opcode & 0xffff;
+
+	INFO_MSG("op %u idn %u size %u(0x%X)", opcode, ioctl_data->idn,
+		 ioctl_data->buf_size, ioctl_data->buf_size);
+
+	buf_len = (ioctl_data->idn == QUERY_DESC_IDN_STRING) ?
+		IOCTL_DEV_CTX_MAX_SIZE : QUERY_DESC_MAX_SIZE;
+
+	kernel_buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!kernel_buf) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	switch (opcode) {
+	case UPIU_QUERY_OPCODE_WRITE_DESC:
+		err = copy_from_user(kernel_buf, buffer +
+				     sizeof(struct ufs_ioctl_query_data),
+				     ioctl_data->buf_size);
+		INFO_MSG("buf size %d", ioctl_data->buf_size);
+		ufsf_print_query_buf(kernel_buf, ioctl_data->buf_size);
+		if (err)
+			goto out_release_mem;
+		break;
+
+	case UPIU_QUERY_OPCODE_READ_DESC:
+		switch (ioctl_data->idn) {
+		case QUERY_DESC_IDN_UNIT:
+			if (!ufs_is_valid_unit_desc_lun(&ufsf->hba->dev_info, lun, 0)) {
+				ERR_MSG("No unit descriptor for lun 0x%x", lun);
+				err = -EINVAL;
+				goto out_release_mem;
+			}
+			index = lun;
+			INFO_MSG("read lu desc lun: %d", index);
+			break;
+
+		case QUERY_DESC_IDN_STRING:
+			if (!ufs_is_valid_unit_desc_lun(&ufsf->hba->dev_info, lun, 0)) {
+				ERR_MSG("No unit descriptor for lun 0x%x", lun);
+				err = -EINVAL;
+				goto out_release_mem;
+			}
+			err = ufsf_issue_req_dev_ctx(ufsf, lun, kernel_buf,
+					ioctl_data->buf_size);
+			if (err < 0)
+				goto out_release_mem;
+
+			goto copy_buffer;
+		case QUERY_DESC_IDN_DEVICE:
+		case QUERY_DESC_IDN_GEOMETRY:
+		case QUERY_DESC_IDN_CONFIGURATION:
+			break;
+
+		default:
+			ERR_MSG("invalid idn %d", ioctl_data->idn);
+			err = -EINVAL;
+			goto out_release_mem;
+		}
+		break;
+	default:
+		ERR_MSG("invalid opcode %d", opcode);
+		err = -EINVAL;
+		goto out_release_mem;
+	}
+
+	length = ioctl_data->buf_size;
+
+	err = ufshcd_query_descriptor_retry(ufsf->hba, opcode, ioctl_data->idn,
+					    index, 0, kernel_buf,
+					    &length);
+	if (err)
+		goto out_release_mem;
+
+copy_buffer:
+	if (opcode == UPIU_QUERY_OPCODE_READ_DESC ||
+	    opcode == UPIU_QUERY_OPCODE_READ_ATTR) {
+		err = copy_to_user(buffer, ioctl_data,
+				   sizeof(struct ufs_ioctl_query_data));
+		if (err)
+			ERR_MSG("Failed copying back to user.");
+
+		err = copy_to_user(buffer + sizeof(struct ufs_ioctl_query_data),
+				   kernel_buf, ioctl_data->buf_size);
+		if (err)
+			ERR_MSG("Fail: copy rsp_buffer to user space.");
+	}
+out_release_mem:
+	kfree(kernel_buf);
+out:
+	return err;
+}
+
+/*
+ * Mimic ufshcd_copy_sense_data()
+ */
+#define UFS_SENSE_SIZE	18
+static void ufsf_copy_sense_data(struct ufshcd_lrb *lrbp)
+{
+	unsigned int seg_len = be32_to_cpu(lrbp->ucd_rsp_ptr->header.dword_2) &
+		MASK_RSP_UPIU_DATA_SEG_LEN;
+	int len;
+
+	if (lrbp->sense_buffer && seg_len) {
+		int len_to_copy;
+
+		len = be16_to_cpu(lrbp->ucd_rsp_ptr->sr.sense_data_len);
+		len_to_copy = min_t(int, UFS_SENSE_SIZE, len);
+
+		memcpy(lrbp->sense_buffer, lrbp->ucd_rsp_ptr->sr.sense_data,
+		       len_to_copy);
+	}
+}
+
+void ufsf_upiu_check_for_ccd(struct ufshcd_lrb *lrbp)
+{
+	unsigned char *cdb = lrbp->cmd->cmnd;
+	int data_seg_len, sense_data_len;
+	struct utp_cmd_rsp *sr = &lrbp->ucd_rsp_ptr->sr;
+
+	if (cdb[0] != VENDOR_OP || cdb[1] != VENDOR_CCD)
+		return;
+
+	data_seg_len = be32_to_cpu(lrbp->ucd_rsp_ptr->header.dword_2) &
+				       MASK_RSP_UPIU_DATA_SEG_LEN;
+	sense_data_len = be16_to_cpu(lrbp->ucd_rsp_ptr->sr.sense_data_len);
+
+	if (data_seg_len != CCD_DATA_SEG_LEN ||
+	    sense_data_len != CCD_SENSE_DATA_LEN) {
+		WARN_MSG("CCD info is wrong. so check it.");
+		WARN_MSG("CCD data_seg_len = %d, sense_data_len %d",
+			 data_seg_len, sense_data_len);
+	} else {
+		INFO_MSG("CCD info is correct!!");
+	}
+
+	INFO_MSG("sense : %02X %02X %02X %02X %02X %02X\n",
+		 sr->sense_data[0], sr->sense_data[1], sr->sense_data[2],
+		 sr->sense_data[3], sr->sense_data[4], sr->sense_data[5]);
+
+	/*
+	 * sense_len will be not set as Descriptor Type isn't 0x70
+	 * if not set sense_len, sense will not be able to copy
+	 * in sg_scsi_ioctl()
+	 */
+	lrbp->cmd->req.sense_len = CCD_SENSE_DATA_LEN;
+
+	ufsf_copy_sense_data(lrbp);
+}
+
+inline int ufsf_get_scsi_device(struct ufs_hba *hba, struct scsi_device *sdev)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	ret = scsi_device_get(sdev);
+	if (!ret && !scsi_device_online(sdev)) {
+		spin_unlock_irqrestore(hba->host->host_lock, flags);
+		scsi_device_put(sdev);
+		ERR_MSG("scsi_device_get failed.(%d)", ret);
+		return -ENODEV;
+	}
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+
+	return ret;
+}
+
+inline bool ufsf_is_valid_lun(int lun)
+{
+	return lun < UFS_UPIU_MAX_GENERAL_LUN;
+}
+
+inline void ufsf_slave_configure(struct ufsf_feature *ufsf,
+				 struct scsi_device *sdev)
+{
+	if (ufsf_is_valid_lun(sdev->lun)) {
+		ufsf->sdev_ufs_lu[sdev->lun] = sdev;
+		ufsf->slave_conf_cnt++;
+		INFO_MSG("lun[%d] sdev(%p) q(%p) slave_conf_cnt(%d)",
+			 (int)sdev->lun, sdev, sdev->request_queue,
+			 ufsf->slave_conf_cnt);
+
+	}
+	schedule_work(&ufsf->device_check_work);
+}
+
+inline int ufsf_prep_fn(struct ufsf_feature *ufsf, struct ufshcd_lrb *lrbp)
+{
+	int ret = 0;
+
+#if defined(CONFIG_UFSSID)
+	if (ufsf->sid_dev)
+		ufssid_prep_fn(ufsf, lrbp);
+#endif
+	return ret;
+}
+
+/*
+ * called by ufshcd_vops_device_reset()
+ */
+inline void ufsf_reset_host(struct ufsf_feature *ufsf)
+{
+	struct ufs_hba *hba = ufsf->hba;
+	struct Scsi_Host *host = hba->host;
+	unsigned long flags;
+	u32 eh_flags;
+
+	if (!ufsf->check_init)
+		return;
+
+	/*
+	 * Check if it is error handling(eh) context.
+	 *
+	 * In the following cases, we can enter here even though it is not in eh
+	 * context.
+	 *  - when ufshcd_is_link_off() is true in ufshcd_resume()
+	 *  - when ufshcd_vops_suspend() fails in ufshcd_suspend()
+	 */
+	spin_lock_irqsave(host->host_lock, flags);
+	eh_flags = ufshcd_eh_in_progress(hba);
+	spin_unlock_irqrestore(host->host_lock, flags);
+	if (!eh_flags)
+		return;
+
+#if defined(CONFIG_UFSHID)
+	INFO_MSG("run reset_host.. hid_state(%d) -> HID_RESET",
+		 ufshid_get_state(ufsf));
+	if (ufshid_get_state(ufsf) == HID_PRESENT)
+		ufshid_reset_host(ufsf);
+#endif
+	schedule_work(&ufsf->reset_wait_work);
+}
+
+inline void ufsf_init(struct ufsf_feature *ufsf)
+{
+#if defined(CONFIG_UFSHID)
+	if (ufshid_get_state(ufsf) == HID_NEED_INIT)
+		ufshid_init(ufsf);
+#endif
+#if defined(CONFIG_UFSSID)
+	if (ufsf->sid_dev)
+		ufssid_init(ufsf);
+#endif
+
+	ufsf->check_init = true;
+}
+
+inline void ufsf_reset(struct ufsf_feature *ufsf)
+{
+#if defined(CONFIG_UFSHID)
+	if (ufshid_get_state(ufsf) == HID_RESET)
+		ufshid_reset(ufsf);
+#endif
+}
+
+inline void ufsf_remove(struct ufsf_feature *ufsf)
+{
+#if defined(CONFIG_UFSHID)
+	if (ufshid_get_state(ufsf) == HID_PRESENT)
+		ufshid_remove(ufsf);
+#endif
+#if defined(CONFIG_UFSSID)
+	if (ufsf->sid_dev)
+		ufssid_remove(ufsf);
+#endif
+}
+
+static void ufsf_device_check_work_handler(struct work_struct *work)
+{
+	struct ufsf_feature *ufsf;
+
+	ufsf = container_of(work, struct ufsf_feature, device_check_work);
+
+	mutex_lock(&ufsf->device_check_lock);
+	if (!ufsf->check_init) {
+		ufsf_device_check(ufsf->hba);
+		ufsf_init(ufsf);
+	}
+	mutex_unlock(&ufsf->device_check_lock);
+}
+/*
+ * worker to change the feature state to present after processing the error handler.
+ */
+static void ufsf_reset_wait_work_handler(struct work_struct *work)
+{
+	struct ufsf_feature *ufsf;
+	struct ufs_hba *hba;
+	struct Scsi_Host *host;
+	u32 ufshcd_state;
+	unsigned long flags;
+
+	ufsf = container_of(work, struct ufsf_feature, reset_wait_work);
+	hba = ufsf->hba;
+	host = hba->host;
+
+	/*
+	 * Wait completion of hba->eh_work.
+	 *
+	 * reset_wait_work is scheduled at ufsf_reset_host(),
+	 * so it can be waken up before eh_work is completed.
+	 *
+	 * ufsf_reset must be called after eh_work has completed.
+	 */
+	flush_work(&hba->eh_work);
+
+	spin_lock_irqsave(host->host_lock, flags);
+	ufshcd_state = hba->ufshcd_state;
+	spin_unlock_irqrestore(host->host_lock, flags);
+
+	if (ufshcd_state == UFSHCD_STATE_OPERATIONAL)
+		ufsf_reset(ufsf);
+}
+
+static void ufsf_resume_work_handler(struct work_struct *work)
+{
+	struct ufsf_feature *ufsf = container_of(work, struct ufsf_feature, resume_work);
+	struct ufs_hba *hba = ufsf->hba;
+	bool is_link_off = ufshcd_is_link_off(hba);
+
+	/*
+	 * Resume of UFS feature should be called after power & link state
+	 * are changed to active. Therefore, it is synchronized as follows.
+	 *
+	 * System PM: waits to acquire the semaphore used by ufshcd_wl_resume()
+	 * Runtime PM: resume using ufshcd_rpm_get_sync()
+	 */
+	down(&hba->host_sem);
+	ufshcd_rpm_get_sync(hba);
+
+	if (ufshcd_is_ufs_dev_active(hba) && ufshcd_is_link_active(hba))
+		ufsf_resume(ufsf, is_link_off);
+
+	ufshcd_rpm_put_sync(hba);
+	up(&hba->host_sem);
+}
+
+#if defined(CONFIG_UFSHID)
+static void ufsf_on_idle(struct work_struct *work)
+{
+	struct ufsf_feature *ufsf;
+
+	ufsf = container_of(work, struct ufsf_feature, on_idle_work);
+	if (ufshid_get_state(ufsf) == HID_PRESENT)
+		ufshid_on_idle(ufsf);
+}
+#endif
+
+inline void ufsf_set_init_state(struct ufs_hba *hba)
+{
+	struct ufsf_feature *ufsf = ufs_qcom_get_ufsf(hba);
+
+	ufsf->hba = hba;
+	ufsf->slave_conf_cnt = 0;
+	ufsf->issue_ioctl = false;
+
+	mutex_init(&ufsf->device_check_lock);
+	INIT_WORK(&ufsf->device_check_work, ufsf_device_check_work_handler);
+	INIT_WORK(&ufsf->reset_wait_work, ufsf_reset_wait_work_handler);
+	INIT_WORK(&ufsf->resume_work, ufsf_resume_work_handler);
+
+#if defined(CONFIG_UFSHID)
+	INIT_WORK(&ufsf->on_idle_work, ufsf_on_idle);
+	ufshid_set_state(ufsf, HID_NEED_INIT);
+#endif
+}
+
+inline void ufsf_suspend(struct ufsf_feature *ufsf)
+{
+	/*
+	 * Wait completion of reset_wait_work.
+	 *
+	 * When suspend occurrs immediately after reset
+	 * and reset_wait_work is executed late,
+	 * we can enter here before ufsf_reset() cleans up the feature's reset sequence.
+	 */
+	flush_work(&ufsf->reset_wait_work);
+
+#if defined(CONFIG_UFSHID)
+	if (ufshid_get_state(ufsf) == HID_PRESENT)
+		ufshid_suspend(ufsf);
+#endif
+}
+
+inline void ufsf_resume(struct ufsf_feature *ufsf, bool is_link_off)
+{
+#if defined(CONFIG_UFSHID)
+	if (ufshid_get_state(ufsf) == HID_SUSPEND)
+		ufshid_resume(ufsf);
+#endif
+}
+
+inline void ufsf_change_lun(struct ufsf_feature *ufsf,
+			    struct ufshcd_lrb *lrbp)
+{
+	int ctx_lba = get_unaligned_be32(lrbp->cmd->cmnd + 2);
+
+	if (unlikely(ufsf->issue_ioctl == true &&
+	    ctx_lba == READ10_DEBUG_LBA)) {
+		lrbp->lun = READ10_DEBUG_LUN;
+		INFO_MSG("lun 0x%X lba 0x%X", lrbp->lun, ctx_lba);
+	}
+}
+
+/*
+ * Wrapper functions for ufshid.
+ */
+#if defined(CONFIG_UFSHID) && defined(CONFIG_UFSHID_DEBUG)
+inline void ufsf_hid_acc_io_stat(struct ufsf_feature *ufsf,
+				 struct ufshcd_lrb *lrbp)
+{
+	if (ufshid_get_state(ufsf) == HID_PRESENT)
+		ufshid_acc_io_stat_during_trigger(ufsf, lrbp);
+}
+#else
+inline void ufsf_hid_acc_io_stat(struct ufsf_feature *ufsf,
+				 struct ufshcd_lrb *lrbp) {}
+#endif
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/scsi/ufs/vendor/ufsfeature.h b/drivers/scsi/ufs/vendor/ufsfeature.h
new file mode 100644
index 0000000000000..87f44ebac70d3
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufsfeature.h
@@ -0,0 +1,217 @@
+/*
+ * Universal Flash Storage Feature Support
+ *
+ * Copyright (C) 2017-2018 Samsung Electronics Co., Ltd.
+ *
+ * Authors:
+ *	Yongmyung Lee <ymhungry.lee@samsung.com>
+ *	Jinyoung Choi <j-young.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ *
+ * The Linux Foundation chooses to take subject only to the GPLv2
+ * license terms, and distributes only under these terms.
+ */
+
+#ifndef _UFSFEATURE_H_
+#define _UFSFEATURE_H_
+
+#include <scsi/scsi_cmnd.h>
+#include <asm/unaligned.h>
+
+#include "ufs.h"
+
+#include "ufshid.h"
+#include "ufssid.h"
+
+#define UFS_UPIU_MAX_GENERAL_LUN		8
+
+/* UFSHCD error handling flags */
+enum {
+	UFSHCD_EH_IN_PROGRESS = (1 << 0),		/* ufshcd.c */
+};
+#define ufshcd_eh_in_progress(h) \
+	((h)->eh_flags & UFSHCD_EH_IN_PROGRESS)		/* ufshcd.c */
+
+
+#define UFSFEATURE_QUERY_OPCODE			0x5500
+
+/* Version info */
+#define UFSFEATURE_DD_VER			0x030100
+#define UFSFEATURE_DD_VER_POST			""
+
+/* For read10 debug */
+#define READ10_DEBUG_LUN			0x7F
+#define READ10_DEBUG_LBA			0x48504230
+
+/* For Chip Crack Detection */
+#define VENDOR_OP                               0xC0
+#define VENDOR_CCD                              0x51
+#define CCD_DATA_SEG_LEN                        0x08
+#define CCD_SENSE_DATA_LEN                      0x06
+#define CCD_DESC_TYPE                           0x81
+
+/* Constant value*/
+#define SECTOR					512
+#define BLOCK					4096
+#define SECTORS_PER_BLOCK			(BLOCK / SECTOR)
+#define BITS_PER_DWORD				32
+#define sects_per_blk_shift			3
+#define bits_per_dword_shift			5
+#define bits_per_dword_mask			0x1F
+#define bits_per_byte_shift			3
+
+#define IOCTL_DEV_CTX_MAX_SIZE			OS_PAGE_SIZE
+#define OS_PAGE_SIZE				4096
+#define OS_PAGE_SHIFT				12
+
+#define UFSF_QUERY_REQ_RETRIES			1
+
+/* Description */
+#define UFSF_QUERY_DESC_DEVICE_MAX_SIZE		0xFF
+#define UFSF_QUERY_DESC_CONFIGURAION_MAX_SIZE	0xE6
+/* Descriptor idn for Query Request */
+#define UFSF_QUERY_DESC_IDN_DEVICE		0xF0
+
+/* query_flag  */
+#define MASK_QUERY_UPIU_FLAG_LOC		0xFF
+
+/* For read10 debug */
+#define READ10_DEBUG_LUN			0x7F
+#define READ10_DEBUG_LBA			0x48504230
+
+#define INFO_MSG(msg, args...)		pr_info("%s:%d info: " msg "\n", \
+					       __func__, __LINE__, ##args)
+#define ERR_MSG(msg, args...)		pr_err("%s:%d err: " msg "\n", \
+					       __func__, __LINE__, ##args)
+#define WARN_MSG(msg, args...)		pr_warn("%s:%d warn: " msg "\n", \
+					       __func__, __LINE__, ##args)
+
+#define TMSG(ufsf, lun, msg, args...)					\
+	do { if (ufsf->sdev_ufs_lu[lun] &&				\
+		 ufsf->sdev_ufs_lu[lun]->request_queue)			\
+		blk_add_trace_msg(					\
+			ufsf->sdev_ufs_lu[lun]->request_queue,		\
+			msg, ##args);					\
+	} while (0)							\
+
+struct ufsf_feature {
+	struct ufs_hba *hba;
+	int num_lu;
+	int slave_conf_cnt;
+	struct scsi_device *sdev_ufs_lu[UFS_UPIU_MAX_GENERAL_LUN];
+	bool issue_ioctl;
+	bool check_init;
+	struct work_struct device_check_work;
+	struct mutex device_check_lock;
+
+	struct work_struct reset_wait_work;
+	struct work_struct resume_work;
+
+#if defined(CONFIG_UFSHID)
+	struct work_struct on_idle_work;
+	atomic_t hid_state;
+	struct ufshid_dev *hid_dev;
+#endif
+#if defined(CONFIG_UFSSID)
+	struct ufssid_dev *sid_dev;
+#endif
+};
+
+struct ufs_hba;
+struct ufshcd_lrb;
+struct ufs_ioctl_query_data;
+
+void ufsf_device_check(struct ufs_hba *hba);
+int ufsf_query_ioctl(struct ufsf_feature *ufsf, int lun, void __user *buffer,
+		     struct ufs_ioctl_query_data *ioctl_data);
+void ufsf_upiu_check_for_ccd(struct ufshcd_lrb *lrbp);
+int ufsf_get_scsi_device(struct ufs_hba *hba, struct scsi_device *sdev);
+bool ufsf_is_valid_lun(int lun);
+void ufsf_slave_configure(struct ufsf_feature *ufsf, struct scsi_device *sdev);
+void ufsf_change_lun(struct ufsf_feature *ufsf, struct ufshcd_lrb *lrbp);
+
+int ufsf_prep_fn(struct ufsf_feature *ufsf, struct ufshcd_lrb *lrbp);
+void ufsf_reset_host(struct ufsf_feature *ufsf);
+void ufsf_init(struct ufsf_feature *ufsf);
+void ufsf_reset(struct ufsf_feature *ufsf);
+void ufsf_remove(struct ufsf_feature *ufsf);
+void ufsf_set_init_state(struct ufs_hba *hba);
+void ufsf_suspend(struct ufsf_feature *ufsf);
+void ufsf_resume(struct ufsf_feature *ufsf, bool is_link_off);
+
+/* mimic */
+int ufsf_issue_tm_cmd(struct ufs_hba *hba, int lun_id, int task_id,
+		      u8 tm_function, u8 *tm_response);
+void ufsf_scsi_unblock_requests(struct ufs_hba *hba);
+void ufsf_scsi_block_requests(struct ufs_hba *hba);
+int ufsf_wait_for_doorbell_clr(struct ufs_hba *hba, u64 wait_timeout_us);
+
+/* for hid */
+void ufsf_hid_acc_io_stat(struct ufsf_feature *ufsf, struct ufshcd_lrb *lrbp);
+
+/* Flag idn for Query Requests*/
+#if defined(CONFIG_UFSSID)
+#define QUERY_FLAG_IDN_STREAM_ID_EN			0x81
+#endif
+
+/* Attribute idn for Query requests */
+#if defined(CONFIG_UFSHID)
+#define QUERY_ATTR_IDN_HID_OPERATION			0x80
+#define QUERY_ATTR_IDN_HID_FRAG_LEVEL			0x81
+#endif
+
+/* Device descriptor parameters offsets in bytes*/
+#define DEVICE_DESC_PARAM_EX_FEAT_SUP			0x4F
+#define DEVICE_DESC_PARAM_SAMSUNG_SUP			0xFB
+#if defined(CONFIG_UFSHID)
+#define DEVICE_DESC_PARAM_HID_VER			0xF7
+#endif
+#if defined(CONFIG_UFSSID)
+#define DEVICE_DESC_PARAM_SID_VER			0xEF
+#endif
+
+/**
+ * struct utp_upiu_task_req - Task request UPIU structure
+ * @header - UPIU header structure DW0 to DW-2
+ * @input_param1: Input parameter 1 DW-3
+ * @input_param2: Input parameter 2 DW-4
+ * @input_param3: Input parameter 3 DW-5
+ * @reserved: Reserved double words DW-6 to DW-7
+ */
+struct utp_upiu_task_req {
+	struct utp_upiu_header header;
+	__be32 input_param1;
+	__be32 input_param2;
+	__be32 input_param3;
+	__be32 reserved[2];
+};
+
+static inline int ufsf_check_query(__u32 opcode)
+{
+	return (opcode & 0xffff0000) >> 16 == UFSFEATURE_QUERY_OPCODE;
+}
+
+#endif /* End of Header */
diff --git a/drivers/scsi/ufs/vendor/ufshid.c b/drivers/scsi/ufs/vendor/ufshid.c
new file mode 100644
index 0000000000000..4265a9ae90efe
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufshid.c
@@ -0,0 +1,1088 @@
+/*
+ * Universal Flash Storage Host Initiated Defrag
+ *
+ * Copyright (C) 2019 Samsung Electronics Co., Ltd.
+ *
+ * Authors:
+ *	Yongmyung Lee <ymhungry.lee@samsung.com>
+ *	Jinyoung Choi <j-young.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ *
+ * The Linux Foundation chooses to take subject only to the GPLv2
+ * license terms, and distributes only under these terms.
+ */
+
+#include "ufshcd.h"
+#include "ufsfeature.h"
+#include "ufshid.h"
+
+static int ufshid_create_sysfs(struct ufshid_dev *hid);
+
+static inline void ufshid_rpm_put_noidle(struct ufs_hba *hba)
+{
+	pm_runtime_put_noidle(&hba->sdev_ufs_device->sdev_gendev);
+}
+
+static inline int ufshid_schedule_delayed_work(struct delayed_work *work,
+					       unsigned long delay)
+{
+	return queue_delayed_work(system_freezable_wq, work, delay);
+}
+
+inline int ufshid_get_state(struct ufsf_feature *ufsf)
+{
+	return atomic_read(&ufsf->hid_state);
+}
+
+inline void ufshid_set_state(struct ufsf_feature *ufsf, int state)
+{
+	atomic_set(&ufsf->hid_state, state);
+}
+
+static inline int ufshid_is_not_present(struct ufshid_dev *hid)
+{
+	enum UFSHID_STATE cur_state = ufshid_get_state(hid->ufsf);
+
+	if (cur_state != HID_PRESENT) {
+		INFO_MSG("hid_state != HID_PRESENT (%d)", cur_state);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int ufshid_read_attr(struct ufshid_dev *hid, u8 idn, u32 *attr_val)
+{
+	struct ufs_hba *hba = hid->ufsf->hba;
+	int ret = 0;
+
+	ufshcd_rpm_get_sync(hba);
+
+	ret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR, idn, 0,
+				      0, attr_val);
+	if (ret) {
+		ERR_MSG("read attr [0x%.2X] fail. (%d)", idn, ret);
+		goto err_out;
+	}
+
+	HID_DEBUG(hid, "hid_attr read [0x%.2X] %u (0x%X)", idn, *attr_val,
+		  *attr_val);
+	TMSG(hid->ufsf, 0, "[ufshid] read_attr IDN %s (%d)",
+	     idn == QUERY_ATTR_IDN_HID_OPERATION ? "HID_OP" :
+	     idn == QUERY_ATTR_IDN_HID_FRAG_LEVEL ? "HID_LEV" : "UNKNOWN", idn);
+err_out:
+	ufshid_rpm_put_noidle(hba);
+
+	return ret;
+}
+
+static int ufshid_write_attr(struct ufshid_dev *hid, u8 idn, u32 val)
+{
+	struct ufs_hba *hba = hid->ufsf->hba;
+	int ret = 0;
+
+	ufshcd_rpm_get_sync(hba);
+
+	ret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_WRITE_ATTR, idn, 0,
+				      0, &val);
+	if (ret) {
+		ERR_MSG("write attr [0x%.2X] fail. (%d)", idn, ret);
+		goto err_out;
+	}
+
+	HID_DEBUG(hid, "hid_attr write [0x%.2X] %u (0x%X)", idn, val, val);
+	TMSG(hid->ufsf, 0, "[ufshid] write_attr IDN %s (%d)",
+	     idn == QUERY_ATTR_IDN_HID_OPERATION ? "HID_OP" :
+	     idn == QUERY_ATTR_IDN_HID_FRAG_LEVEL ? "HID_LEV" : "UNKNOWN", idn);
+err_out:
+	ufshid_rpm_put_noidle(hba);
+
+	return ret;
+}
+
+static inline int ufshid_version_check(int spec_version)
+{
+	INFO_MSG("Support HID Spec : Driver = (%.4x), Device = (%.4x)",
+		 UFSHID_VER, spec_version);
+	INFO_MSG("HID Driver version (%.6X%s)",
+		 UFSHID_DD_VER, UFSHID_DD_VER_POST);
+
+	if (spec_version != UFSHID_VER) {
+		ERR_MSG("UFS HID version mismatched");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+void ufshid_get_dev_info(struct ufsf_feature *ufsf, u8 *desc_buf)
+{
+	int ret = 0, spec_version;
+
+	ufsf->hid_dev = NULL;
+
+	if (!(get_unaligned_be32(desc_buf + DEVICE_DESC_PARAM_SAMSUNG_SUP) &
+	      UFS_FEATURE_SUPPORT_HID_BIT)) {
+		INFO_MSG("bUFSExFeaturesSupport: HID not support");
+		goto err_out;
+	}
+
+	INFO_MSG("bUFSExFeaturesSupport: HID support");
+	spec_version = get_unaligned_be16(desc_buf + DEVICE_DESC_PARAM_HID_VER);
+	ret = ufshid_version_check(spec_version);
+	if (ret)
+		goto err_out;
+
+	ufsf->hid_dev = kzalloc(sizeof(struct ufshid_dev), GFP_KERNEL);
+	if (!ufsf->hid_dev) {
+		ERR_MSG("hid_dev memalloc fail");
+		goto err_out;
+	}
+
+	ufsf->hid_dev->ufsf = ufsf;
+	return;
+err_out:
+	ufshid_set_state(ufsf, HID_FAILED);
+}
+
+static int ufshid_execute_query_op(struct ufshid_dev *hid, enum UFSHID_OP op,
+				   u32 *attr_val)
+{
+	if (ufshid_write_attr(hid, QUERY_ATTR_IDN_HID_OPERATION, op))
+		return -EINVAL;
+
+	msleep(200);
+
+	if (ufshid_read_attr(hid, QUERY_ATTR_IDN_HID_FRAG_LEVEL, attr_val))
+		return -EINVAL;
+
+	HID_DEBUG(hid, "Frag_lv %d Frag_stat %d HID_need_exec %d",
+		  HID_GET_FRAG_LEVEL(*attr_val),
+		  HID_FRAG_UPDATE_STAT(*attr_val),
+		  HID_EXECUTE_REQ_STAT(*attr_val));
+
+	return 0;
+}
+
+static int ufshid_get_analyze_and_issue_execute(struct ufshid_dev *hid)
+{
+	u32 attr_val;
+	int ret;
+
+	ret = ufshid_execute_query_op(hid, HID_OP_EXECUTE, &attr_val);
+	if (ret)
+		return ret;
+
+	if (HID_GET_FRAG_LEVEL(attr_val) == HID_LEV_GRAY)
+		return -EAGAIN;
+
+	return (HID_EXECUTE_REQ_STAT(attr_val)) ?
+		HID_REQUIRED : HID_NOT_REQUIRED;
+}
+
+static inline void ufshid_issue_disable(struct ufshid_dev *hid)
+{
+	u32 attr_val;
+
+	ufshid_execute_query_op(hid, HID_OP_DISABLE, &attr_val);
+}
+
+/*
+ * Lock status: hid_sysfs lock was held when called.
+ */
+static void ufshid_auto_hibern8_enable(struct ufshid_dev *hid,
+				       unsigned int val)
+{
+	struct ufs_hba *hba = hid->ufsf->hba;
+	unsigned long flags;
+	u32 reg;
+
+	val = !!val;
+
+	/* Update auto hibern8 timer value if supported */
+	if (!ufshcd_is_auto_hibern8_supported(hba))
+		return;
+
+	ufshcd_rpm_get_sync(hba);
+	ufshcd_hold(hba, false);
+	down_write(&hba->clk_scaling_lock);
+	ufsf_scsi_block_requests(hba);
+	/* wait for all the outstanding requests to finish */
+	ufsf_wait_for_doorbell_clr(hba, U64_MAX);
+	spin_lock_irqsave(hba->host->host_lock, flags);
+
+	reg = ufshcd_readl(hba, REG_AUTO_HIBERNATE_IDLE_TIMER);
+	INFO_MSG("ahit-reg 0x%X", reg);
+
+	if (val ^ (reg != 0)) {
+		if (val) {
+			hba->ahit = hid->ahit;
+		} else {
+			/*
+			 * Store current ahit value.
+			 * We don't know who set the ahit value to different
+			 * from the initial value
+			 */
+			hid->ahit = reg;
+			hba->ahit = 0;
+		}
+
+		ufshcd_writel(hba, hba->ahit, REG_AUTO_HIBERNATE_IDLE_TIMER);
+
+		/* Make sure the timer gets applied before further operations */
+		mb();
+
+		INFO_MSG("[Before] is_auto_enabled %d", hid->is_auto_enabled);
+		hid->is_auto_enabled = val;
+
+		reg = ufshcd_readl(hba, REG_AUTO_HIBERNATE_IDLE_TIMER);
+		INFO_MSG("[After] is_auto_enabled %d ahit-reg 0x%X",
+			 hid->is_auto_enabled, reg);
+	} else {
+		INFO_MSG("is_auto_enabled %d. so it does not changed",
+			 hid->is_auto_enabled);
+	}
+
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+	ufsf_scsi_unblock_requests(hba);
+	up_write(&hba->clk_scaling_lock);
+	ufshcd_release(hba);
+	ufshid_rpm_put_noidle(hba);
+}
+
+static void ufshid_block_enter_suspend(struct ufshid_dev *hid)
+{
+	struct ufs_hba *hba = hid->ufsf->hba;
+	struct device *dev = &hba->sdev_ufs_device->sdev_gendev;
+	unsigned long flags;
+
+#if defined(CONFIG_UFSHID_POC)
+	if (unlikely(hid->block_suspend))
+		return;
+
+	hid->block_suspend = true;
+#endif
+	ufshcd_rpm_get_sync(hba);
+	ufshcd_hold(hba, false);
+
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	HID_DEBUG(hid,
+		  "dev->power.usage_count %d hba->clk_gating.active_reqs %d",
+		  atomic_read(&dev->power.usage_count),
+		  hba->clk_gating.active_reqs);
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+}
+
+/*
+ * The HID feature can be executed in the SPM by using a kernel thread.
+ * By strongly checking the conditions,
+ * it constraints to be performed only in the RPM.
+ *
+ * If the return value is not err, pm_runtime_put_noidle() must be called later.
+ *
+ * IMPORTANT : ufshid_hold_runtime_pm() & ufshid_release_runtime_pm() pair.
+ */
+static int ufshid_hold_runtime_pm(struct ufshid_dev *hid)
+{
+	struct ufsf_feature *ufsf = hid->ufsf;
+	struct ufs_hba *hba = ufsf->hba;
+	struct device *dev = &hba->sdev_ufs_device->sdev_gendev;
+
+	if (ufshid_get_state(ufsf) == HID_SUSPEND) {
+		/*
+		 * Check that device was suspended by System PM
+		 */
+		if (!hba->pm_op_in_progress && dev->power.is_suspended)
+			return -EACCES;
+
+		/*
+		 * Double Check for safe (SPM vs RPM)
+		 * If it success, device was suspended by Runtime PM
+		 */
+		ufshcd_rpm_get_sync(hba);
+
+		/*
+		 * Guaranteed that ufsf_resume() is completed
+		 */
+		down(&hba->host_sem);
+		up(&hba->host_sem);
+
+		if (ufshid_get_state(ufsf) == HID_PRESENT &&
+		    hba->curr_dev_pwr_mode == UFS_ACTIVE_PWR_MODE &&
+		    hba->uic_link_state == UIC_LINK_ACTIVE_STATE)
+			goto resume_success;
+
+		INFO_MSG("RPM resume failed. Maybe it was SPM suspend");
+		INFO_MSG("UFS state (POWER = %d LINK = %d)",
+			 hba->curr_dev_pwr_mode, hba->uic_link_state);
+
+		ufshid_rpm_put_noidle(hba);
+		return -EACCES;
+	}
+
+	if (ufshid_is_not_present(hid))
+		return -ENODEV;
+
+	ufshcd_rpm_get_sync(hba);
+resume_success:
+	return 0;
+}
+
+static inline void ufshid_release_runtime_pm(struct ufshid_dev *hid)
+{
+	struct ufs_hba *hba = hid->ufsf->hba;
+
+	ufshid_rpm_put_noidle(hba);
+}
+
+/*
+ *  The method using HID for each vendor may be different.
+ *  So, the functions were exposed to direct control in other kernel processes.
+ *
+ *  Lock status: hid->sysfs_lock was held when called.
+ */
+int ufshid_trigger_on(struct ufshid_dev *hid) __must_hold(&hid->sysfs_lock)
+{
+	int ret;
+
+	lockdep_assert_held(&hid->sysfs_lock);
+
+	if (hid->hid_trigger)
+		return 0;
+
+	ret = ufshid_hold_runtime_pm(hid);
+	if (ret)
+		return ret;
+
+	hid->hid_trigger = true;
+	HID_DEBUG(hid, "trigger 0 -> 1");
+
+	ufshid_block_enter_suspend(hid);
+
+	ufshid_auto_hibern8_enable(hid, 0);
+
+	ufshid_schedule_delayed_work(&hid->hid_trigger_work, 0);
+
+	ufshid_release_runtime_pm(hid);
+
+	return 0;
+}
+
+static void ufshid_allow_enter_suspend(struct ufshid_dev *hid)
+{
+	struct ufs_hba *hba = hid->ufsf->hba;
+	struct device *dev = &hba->sdev_ufs_device->sdev_gendev;
+	unsigned long flags;
+
+#if defined(CONFIG_UFSHID_POC)
+	if (unlikely(!hid->block_suspend))
+		return;
+
+	hid->block_suspend = false;
+#endif
+	ufshcd_release(hba);
+	ufshid_rpm_put_noidle(hba);
+
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	HID_DEBUG(hid,
+		  "dev->power.usage_count %d hba->clk_gating.active_reqs %d",
+		  atomic_read(&dev->power.usage_count),
+		  hba->clk_gating.active_reqs);
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+}
+
+/*
+ *  The method using HID for each vendor may be different.
+ *  So, the functions were exposed to direct control in other kernel processes.
+ *
+ *  Lock status: hid->sysfs_lock was held when called.
+ */
+int ufshid_trigger_off(struct ufshid_dev *hid) __must_hold(&hid->sysfs_lock)
+{
+	int ret;
+
+	lockdep_assert_held(&hid->sysfs_lock);
+
+	if (!hid->hid_trigger)
+		return 0;
+
+	ret = ufshid_hold_runtime_pm(hid);
+	if (ret)
+		return ret;
+
+	hid->hid_trigger = false;
+	HID_DEBUG(hid, "hid_trigger 1 -> 0");
+
+	ufshid_issue_disable(hid);
+
+	ufshid_auto_hibern8_enable(hid, 1);
+
+	ufshid_allow_enter_suspend(hid);
+
+	ufshid_release_runtime_pm(hid);
+
+	return 0;
+}
+
+#if defined(CONFIG_UFSHID_DEBUG)
+static void ufshid_print_hid_info(struct ufshid_dev *hid)
+{
+	struct ufs_hba *hba = hid->ufsf->hba;
+	unsigned long flags;
+
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	HID_DEBUG(hid, "r_cnt %llu w_cnt %llu r_sectors %llu w_sectors %llu "
+		  "w_query_cnt %llu", hid->read_cnt, hid->write_cnt,
+		  hid->read_sec, hid->write_sec, hid->write_query_cnt);
+
+	hid->read_cnt = hid->write_cnt = hid->read_sec = hid->write_sec = 0;
+	hid->write_query_cnt = 0;
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+}
+
+/*
+ * Lock status: hba->host->host_lock was held when called.
+ * So, Don't need to use atomic operation for stats.
+ */
+void ufshid_acc_io_stat_during_trigger(struct ufsf_feature *ufsf,
+				       struct ufshcd_lrb *lrbp)
+				       __must_hold(ufsf->hba->host->host_lock)
+{
+	struct ufs_hba *hba = ufsf->hba;
+	struct scsi_cmnd *scmd = lrbp->cmd;
+	struct ufshid_dev *hid = ufsf->hid_dev;
+	struct ufs_query_req *request;
+	struct request *req;
+
+	lockdep_assert_held(hba->host->host_lock);
+
+	if (!hid || !hid->hid_trigger)
+		return;
+
+	if (scmd) {
+		req = scsi_cmd_to_rq(scmd);
+		if (scmd->sc_data_direction == DMA_FROM_DEVICE) {
+			hid->read_cnt++;
+			hid->read_sec += blk_rq_sectors(req);
+		} else {
+			hid->write_cnt++;
+			hid->write_sec += blk_rq_sectors(req);
+		}
+	} else {
+		request = &hba->dev_cmd.query.request;
+
+		switch (request->upiu_req.opcode) {
+		case UPIU_QUERY_OPCODE_WRITE_DESC:
+		case UPIU_QUERY_OPCODE_WRITE_ATTR:
+			if (request->upiu_req.idn ==
+			    QUERY_ATTR_IDN_HID_OPERATION)
+				break;
+			fallthrough;
+		case UPIU_QUERY_OPCODE_SET_FLAG:
+		case UPIU_QUERY_OPCODE_CLEAR_FLAG:
+		case UPIU_QUERY_OPCODE_TOGGLE_FLAG:
+			hid->write_query_cnt++;
+			break;
+		default:
+			break;
+		}
+	}
+}
+#endif
+
+static void ufshid_trigger_work_fn(struct work_struct *dwork)
+{
+	struct ufshid_dev *hid;
+	int ret;
+
+	hid = container_of(dwork, struct ufshid_dev, hid_trigger_work.work);
+
+	if (ufshid_is_not_present(hid))
+		return;
+
+	HID_DEBUG(hid, "start hid_trigger_work_fn");
+
+	mutex_lock(&hid->sysfs_lock);
+	if (!hid->hid_trigger) {
+		HID_DEBUG(hid, "hid_trigger == false, return");
+		goto finish_work;
+	}
+
+	ret = ufshid_get_analyze_and_issue_execute(hid);
+	if (ret == HID_REQUIRED || ret == -EAGAIN) {
+		HID_DEBUG(hid, "REQUIRED or AGAIN (%d), so re-sched (%u ms)",
+			  ret, hid->hid_trigger_delay);
+	} else {
+		HID_DEBUG(hid, "NOT_REQUIRED or err (%d), so trigger off", ret);
+		ret = ufshid_trigger_off(hid);
+		if (likely(!ret))
+			goto finish_work;
+
+		WARN_MSG("trigger off fail.. must check it");
+	}
+	mutex_unlock(&hid->sysfs_lock);
+#if defined(CONFIG_UFSHID_DEBUG)
+	ufshid_print_hid_info(hid);
+#endif
+	ufshid_schedule_delayed_work(&hid->hid_trigger_work,
+				     msecs_to_jiffies(hid->hid_trigger_delay));
+
+	HID_DEBUG(hid, "end hid_trigger_work_fn");
+	return;
+finish_work:
+	mutex_unlock(&hid->sysfs_lock);
+}
+
+void ufshid_init(struct ufsf_feature *ufsf)
+{
+	struct ufshid_dev *hid = ufsf->hid_dev;
+	int ret;
+
+	INFO_MSG("HID_INIT_START");
+
+	if (!hid) {
+		ERR_MSG("hid is not found. it is very weired. must check it");
+		ufshid_set_state(ufsf, HID_FAILED);
+		return;
+	}
+
+	hid->hid_trigger = false;
+	hid->hid_trigger_delay = HID_TRIGGER_WORKER_DELAY_MS_DEFAULT;
+	hid->hid_on_idle_delay = HID_ON_IDLE_DELAY_MS_DEFAULT;
+	INIT_DELAYED_WORK(&hid->hid_trigger_work, ufshid_trigger_work_fn);
+
+	hid->hid_debug = false;
+#if defined(CONFIG_UFSHID_POC)
+	hid->hid_debug = true;
+	hid->block_suspend = false;
+#endif
+
+	/* If HCI supports auto hibern8, UFS Driver use it default */
+	hid->is_auto_enabled = ufshcd_is_auto_hibern8_supported(ufsf->hba);
+
+	/* Save default Auto-Hibernate Idle Timer register value */
+	hid->ahit = ufsf->hba->ahit;
+
+	ret = ufshid_create_sysfs(hid);
+	if (ret) {
+		ERR_MSG("sysfs init fail. so hid driver disabled");
+		kfree(hid);
+		ufshid_set_state(ufsf, HID_FAILED);
+		return;
+	}
+
+	INFO_MSG("UFS HID create sysfs finished");
+
+	ufshid_set_state(ufsf, HID_PRESENT);
+}
+
+void ufshid_reset_host(struct ufsf_feature *ufsf)
+{
+	struct ufshid_dev *hid = ufsf->hid_dev;
+
+	if (!hid)
+		return;
+
+	ufshid_set_state(ufsf, HID_RESET);
+	cancel_delayed_work_sync(&hid->hid_trigger_work);
+}
+
+void ufshid_reset(struct ufsf_feature *ufsf)
+{
+	struct ufshid_dev *hid = ufsf->hid_dev;
+
+	if (!hid)
+		return;
+
+	ufshid_set_state(ufsf, HID_PRESENT);
+
+	/*
+	 * hid_trigger will be checked under sysfs_lock in worker.
+	 */
+	if (hid->hid_trigger)
+		ufshid_schedule_delayed_work(&hid->hid_trigger_work, 0);
+
+	INFO_MSG("reset completed.");
+}
+
+static inline void ufshid_remove_sysfs(struct ufshid_dev *hid)
+{
+	int ret;
+
+	ret = kobject_uevent(&hid->kobj, KOBJ_REMOVE);
+	INFO_MSG("kobject removed (%d)", ret);
+	kobject_del(&hid->kobj);
+}
+
+void ufshid_remove(struct ufsf_feature *ufsf)
+{
+	struct ufshid_dev *hid = ufsf->hid_dev;
+	int ret;
+
+	if (!hid)
+		return;
+
+	INFO_MSG("start HID release");
+
+	mutex_lock(&hid->sysfs_lock);
+
+	ret = ufshid_trigger_off(hid);
+	if (unlikely(ret))
+		ERR_MSG("trigger off fail ret (%d)", ret);
+
+	ufshid_remove_sysfs(hid);
+
+	ufshid_set_state(ufsf, HID_FAILED);
+
+	mutex_unlock(&hid->sysfs_lock);
+
+	cancel_delayed_work_sync(&hid->hid_trigger_work);
+
+	kfree(hid);
+
+	INFO_MSG("end HID release");
+}
+
+void ufshid_suspend(struct ufsf_feature *ufsf)
+{
+	struct ufshid_dev *hid = ufsf->hid_dev;
+
+	if (!hid)
+		return;
+
+	if (unlikely(hid->hid_trigger))
+		ERR_MSG("hid_trigger was set to block the suspend. so weird");
+	ufshid_set_state(ufsf, HID_SUSPEND);
+
+	cancel_delayed_work_sync(&hid->hid_trigger_work);
+}
+
+void ufshid_resume(struct ufsf_feature *ufsf)
+{
+	struct ufshid_dev *hid = ufsf->hid_dev;
+
+	if (!hid)
+		return;
+
+	if (unlikely(hid->hid_trigger))
+		ERR_MSG("hid_trigger need to off");
+	ufshid_set_state(ufsf, HID_PRESENT);
+}
+
+/*
+ * this function is called in irq context.
+ * so cancel_delayed_work_sync() do not use due to waiting.
+ */
+void ufshid_on_idle(struct ufsf_feature *ufsf)
+{
+	struct ufshid_dev *hid = ufsf->hid_dev;
+
+	if (!hid)
+		return;
+	/*
+	 * When hid_trigger_work will be scheduled,
+	 * check hid_trigger under sysfs_lock.
+	 */
+	if (!hid->hid_trigger)
+		return;
+
+	if (delayed_work_pending(&hid->hid_trigger_work))
+		cancel_delayed_work(&hid->hid_trigger_work);
+
+	ufshid_schedule_delayed_work(&hid->hid_trigger_work,
+				     hid->hid_on_idle_delay);
+}
+
+/* sysfs function */
+static ssize_t ufshid_sysfs_show_version(struct ufshid_dev *hid, char *buf)
+{
+	INFO_MSG("HID version (%.4X) D/D version (%.6X%s)",
+		 UFSHID_VER, UFSHID_DD_VER, UFSHID_DD_VER_POST);
+
+	return snprintf(buf, PAGE_SIZE,
+			"HID version (%.4X) D/D version (%.6X%s)\n",
+			UFSHID_VER, UFSHID_DD_VER, UFSHID_DD_VER_POST);
+}
+
+static ssize_t ufshid_sysfs_show_trigger(struct ufshid_dev *hid, char *buf)
+{
+	INFO_MSG("hid_trigger %u", hid->hid_trigger);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", hid->hid_trigger);
+}
+
+static ssize_t ufshid_sysfs_store_trigger(struct ufshid_dev *hid,
+					  const char *buf, size_t count)
+{
+	unsigned int val;
+	ssize_t ret;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	INFO_MSG("HID_trigger %u", val);
+
+	if (val == hid->hid_trigger)
+		return count;
+
+	ret = val ? ufshid_trigger_on(hid) : ufshid_trigger_off(hid);
+
+	if (ret) {
+		INFO_MSG("Changing trigger val %u is fail (%ld)", val, ret);
+		return ret;
+	}
+
+	return count;
+}
+
+static ssize_t ufshid_sysfs_show_trigger_interval(struct ufshid_dev *hid,
+						  char *buf)
+{
+	INFO_MSG("hid_trigger_interval %u", hid->hid_trigger_delay);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", hid->hid_trigger_delay);
+}
+
+static ssize_t ufshid_sysfs_store_trigger_interval(struct ufshid_dev *hid,
+						   const char *buf,
+						   size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val < HID_TRIGGER_WORKER_DELAY_MS_MIN ||
+	    val > HID_TRIGGER_WORKER_DELAY_MS_MAX) {
+		INFO_MSG("hid_trigger_interval (min) %4dms ~ (max) %4dms",
+			 HID_TRIGGER_WORKER_DELAY_MS_MIN,
+			 HID_TRIGGER_WORKER_DELAY_MS_MAX);
+		return -EINVAL;
+	}
+
+	hid->hid_trigger_delay = val;
+	INFO_MSG("hid_trigger_interval %u", hid->hid_trigger_delay);
+
+	return count;
+}
+
+static ssize_t ufshid_sysfs_show_on_idle_delay(struct ufshid_dev *hid,
+					       char *buf)
+{
+	INFO_MSG("hid_on_idle_delay %u", hid->hid_on_idle_delay);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", hid->hid_on_idle_delay);
+}
+
+static ssize_t ufshid_sysfs_store_on_idle_delay(struct ufshid_dev *hid,
+						const char *buf,
+						size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val < HID_ON_IDLE_DELAY_MS_MIN || val > HID_ON_IDLE_DELAY_MS_MAX) {
+		INFO_MSG("hid_on_idle_delay (min) %4dms ~ (max) %4dms",
+			 HID_ON_IDLE_DELAY_MS_MIN,
+			 HID_ON_IDLE_DELAY_MS_MAX);
+		return -EINVAL;
+	}
+
+	hid->hid_on_idle_delay = val;
+	INFO_MSG("hid_on_idle_delay %u", hid->hid_on_idle_delay);
+
+	return count;
+}
+
+static ssize_t ufshid_sysfs_show_debug(struct ufshid_dev *hid, char *buf)
+{
+	INFO_MSG("debug %d", hid->hid_debug);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", hid->hid_debug);
+}
+
+static ssize_t ufshid_sysfs_store_debug(struct ufshid_dev *hid, const char *buf,
+					size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	hid->hid_debug = val ? true : false;
+
+	INFO_MSG("debug %d", hid->hid_debug);
+
+	return count;
+}
+
+static ssize_t ufshid_sysfs_show_color(struct ufshid_dev *hid, char *buf)
+{
+	u32 attr_val;
+	int frag_level;
+	int ret;
+
+	ret = ufshid_execute_query_op(hid, HID_OP_ANALYZE, &attr_val);
+	if (ret)
+		return ret;
+
+	frag_level = HID_GET_FRAG_LEVEL(attr_val);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			frag_level == HID_LEV_RED ? "RED" :
+			frag_level == HID_LEV_YELLOW ? "YELLOW" :
+			frag_level == HID_LEV_GREEN ? "GREEN" :
+			frag_level == HID_LEV_GRAY ? "GRAY" : "UNKNOWN");
+}
+
+#if defined(CONFIG_UFSHID_POC)
+static ssize_t ufshid_sysfs_show_debug_op(struct ufshid_dev *hid, char *buf)
+{
+	u32 attr_val;
+
+	if (ufshid_read_attr(hid, QUERY_ATTR_IDN_HID_OPERATION, &attr_val))
+		return -EINVAL;
+
+	INFO_MSG("hid_op %u", attr_val);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", attr_val);
+}
+
+static ssize_t ufshid_sysfs_store_debug_op(struct ufshid_dev *hid,
+					   const char *buf, size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val >= HID_OP_MAX)
+		return -EINVAL;
+
+	if (hid->hid_trigger) {
+		ERR_MSG("debug_op cannot change, current hid_trigger is ON");
+		return -EINVAL;
+	}
+
+	if (ufshid_write_attr(hid, QUERY_ATTR_IDN_HID_OPERATION, val))
+		return -EINVAL;
+
+	INFO_MSG("hid_op %u is set!", val);
+	return count;
+}
+
+static ssize_t ufshid_sysfs_show_block_suspend(struct ufshid_dev *hid,
+					       char *buf)
+{
+	INFO_MSG("block suspend %d", hid->block_suspend);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", hid->block_suspend);
+}
+
+static ssize_t ufshid_sysfs_store_block_suspend(struct ufshid_dev *hid,
+						const char *buf, size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	INFO_MSG("HID_block_suspend %u", val);
+
+	if (val == hid->block_suspend)
+		return count;
+
+	if (val) {
+		ufshid_block_enter_suspend(hid);
+		hid->block_suspend = true;
+	} else {
+		ufshid_allow_enter_suspend(hid);
+		hid->block_suspend = false;
+	}
+
+	return count;
+}
+
+static ssize_t ufshid_sysfs_show_auto_hibern8_enable(struct ufshid_dev *hid,
+						     char *buf)
+{
+	INFO_MSG("HCI auto hibern8 %d", hid->is_auto_enabled);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", hid->is_auto_enabled);
+}
+
+static ssize_t ufshid_sysfs_store_auto_hibern8_enable(struct ufshid_dev *hid,
+						      const char *buf,
+						      size_t count)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	ufshid_auto_hibern8_enable(hid, val);
+
+	return count;
+}
+#endif
+
+/* SYSFS DEFINE */
+#define define_sysfs_ro(_name) __ATTR(_name, 0444,			\
+				      ufshid_sysfs_show_##_name, NULL)
+#define define_sysfs_rw(_name) __ATTR(_name, 0644,			\
+				      ufshid_sysfs_show_##_name,	\
+				      ufshid_sysfs_store_##_name)
+
+static struct ufshid_sysfs_entry ufshid_sysfs_entries[] = {
+	define_sysfs_ro(version),
+	define_sysfs_ro(color),
+
+	define_sysfs_rw(trigger),
+	define_sysfs_rw(trigger_interval),
+	define_sysfs_rw(on_idle_delay),
+
+	/* debug */
+	define_sysfs_rw(debug),
+#if defined(CONFIG_UFSHID_POC)
+	/* Attribute (RAW) */
+	define_sysfs_rw(debug_op),
+	define_sysfs_rw(block_suspend),
+	define_sysfs_rw(auto_hibern8_enable),
+#endif
+	__ATTR_NULL
+};
+
+static ssize_t ufshid_attr_show(struct kobject *kobj, struct attribute *attr,
+				char *page)
+{
+	struct ufshid_sysfs_entry *entry;
+	struct ufshid_dev *hid;
+	ssize_t error;
+
+	entry = container_of(attr, struct ufshid_sysfs_entry, attr);
+	if (!entry->show)
+		return -EIO;
+
+	hid = container_of(kobj, struct ufshid_dev, kobj);
+	error = ufshid_hold_runtime_pm(hid);
+	if (error)
+		return error;
+
+	mutex_lock(&hid->sysfs_lock);
+	error = entry->show(hid, page);
+	mutex_unlock(&hid->sysfs_lock);
+
+	ufshid_release_runtime_pm(hid);
+	return error;
+}
+
+static ssize_t ufshid_attr_store(struct kobject *kobj, struct attribute *attr,
+				 const char *page, size_t length)
+{
+	struct ufshid_sysfs_entry *entry;
+	struct ufshid_dev *hid;
+	ssize_t error;
+
+	entry = container_of(attr, struct ufshid_sysfs_entry, attr);
+	if (!entry->store)
+		return -EIO;
+
+	hid = container_of(kobj, struct ufshid_dev, kobj);
+	error = ufshid_hold_runtime_pm(hid);
+	if (error)
+		return error;
+
+	mutex_lock(&hid->sysfs_lock);
+	error = entry->store(hid, page, length);
+	mutex_unlock(&hid->sysfs_lock);
+
+	ufshid_release_runtime_pm(hid);
+	return error;
+}
+
+static const struct sysfs_ops ufshid_sysfs_ops = {
+	.show = ufshid_attr_show,
+	.store = ufshid_attr_store,
+};
+
+static struct kobj_type ufshid_ktype = {
+	.sysfs_ops = &ufshid_sysfs_ops,
+	.release = NULL,
+};
+
+static int ufshid_create_sysfs(struct ufshid_dev *hid)
+{
+	struct device *dev = hid->ufsf->hba->dev;
+	struct ufshid_sysfs_entry *entry;
+	int err;
+
+	hid->sysfs_entries = ufshid_sysfs_entries;
+
+	kobject_init(&hid->kobj, &ufshid_ktype);
+	mutex_init(&hid->sysfs_lock);
+
+	INFO_MSG("ufshid creates sysfs ufshid %p dev->kobj %p",
+		 &hid->kobj, &dev->kobj);
+
+	err = kobject_add(&hid->kobj, kobject_get(&dev->kobj), "ufshid");
+	if (!err) {
+		for (entry = hid->sysfs_entries; entry->attr.name != NULL;
+		     entry++) {
+			INFO_MSG("ufshid sysfs attr creates: %s",
+				 entry->attr.name);
+			err = sysfs_create_file(&hid->kobj, &entry->attr);
+			if (err) {
+				ERR_MSG("create entry(%s) failed",
+					entry->attr.name);
+				goto kobj_del;
+			}
+		}
+		kobject_uevent(&hid->kobj, KOBJ_ADD);
+	} else {
+		ERR_MSG("kobject_add failed");
+	}
+
+	return err;
+kobj_del:
+	err = kobject_uevent(&hid->kobj, KOBJ_REMOVE);
+	INFO_MSG("kobject removed (%d)", err);
+	kobject_del(&hid->kobj);
+	return -EINVAL;
+}
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/scsi/ufs/vendor/ufshid.h b/drivers/scsi/ufs/vendor/ufshid.h
new file mode 100644
index 0000000000000..26cf19fff69a2
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufshid.h
@@ -0,0 +1,161 @@
+/*
+ * Universal Flash Storage Host Initiated Defrag
+ *
+ * Copyright (C) 2019 Samsung Electronics Co., Ltd.
+ *
+ * Authors:
+ *	Yongmyung Lee <ymhungry.lee@samsung.com>
+ *	Jinyoung Choi <j-young.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ *
+ * The Linux Foundation chooses to take subject only to the GPLv2
+ * license terms, and distributes only under these terms.
+ */
+
+#ifndef _UFSHID_H_
+#define _UFSHID_H_
+
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/blktrace_api.h>
+#include <linux/blkdev.h>
+#include <linux/bitfield.h>
+#include <scsi/scsi_cmnd.h>
+
+#include "../../../block/blk.h"
+
+#define UFSHID_VER					0x0201
+#define UFSHID_DD_VER					0x010400
+#define UFSHID_DD_VER_POST				""
+
+#define UFS_FEATURE_SUPPORT_HID_BIT			(1 << 0)
+
+#define HID_TRIGGER_WORKER_DELAY_MS_DEFAULT	2000
+#define HID_TRIGGER_WORKER_DELAY_MS_MIN		100
+#define HID_TRIGGER_WORKER_DELAY_MS_MAX		10000
+
+#define HID_ON_IDLE_DELAY_MS_DEFAULT		100
+#define HID_ON_IDLE_DELAY_MS_MIN		10
+#define HID_ON_IDLE_DELAY_MS_MAX		10000
+
+#define HID_FRAG_LEVEL_MASK		0xF
+#define HID_GET_FRAG_LEVEL(val)		(val & HID_FRAG_LEVEL_MASK)
+#define HID_FRAG_UPDATE_STAT_SHIFT	30
+#define HID_EXECUTE_REQ_STAT_SHIFT	31
+#define HID_FRAG_UPDATE_STAT(val)	((val >> HID_FRAG_UPDATE_STAT_SHIFT) & 0x1)
+#define HID_EXECUTE_REQ_STAT(val)	((val >> HID_EXECUTE_REQ_STAT_SHIFT) & 0x1)
+
+#define HID_DEBUG(hid, msg, args...)					\
+	do { if (hid->hid_debug)					\
+		pr_err("%40s:%3d [%01d%02d%02d] " msg "\n",		\
+		       __func__, __LINE__,				\
+		       hid->hid_trigger,				\
+		       atomic_read(&hid->ufsf->hba->dev->power.usage_count),\
+		       hid->ufsf->hba->clk_gating.active_reqs, ##args);	\
+	} while (0)
+
+enum UFSHID_STATE {
+	HID_NEED_INIT = 0,
+	HID_PRESENT = 1,
+	HID_SUSPEND = 2,
+	HID_FAILED = -2,
+	HID_RESET = -3,
+};
+
+enum UFSHID_OP {
+	HID_OP_DISABLE	= 0,
+	HID_OP_ANALYZE	= 1,
+	HID_OP_EXECUTE	= 2,
+	HID_OP_MAX
+};
+
+enum {
+	HID_NOT_REQUIRED	= 0,
+	HID_REQUIRED		= 1
+};
+
+enum {
+	HID_LEV_GRAY	= 0,
+	HID_LEV_GREEN	= 1,
+	HID_LEV_YELLOW	= 2,
+	HID_LEV_RED	= 3,
+};
+
+struct ufshid_dev {
+	struct ufsf_feature *ufsf;
+
+	unsigned int hid_trigger;   /* default value is false */
+	struct delayed_work hid_trigger_work;
+	unsigned int hid_trigger_delay;
+	unsigned int hid_on_idle_delay;
+
+	u32 ahit;			/* to restore ahit value */
+	bool is_auto_enabled;
+
+	/* for sysfs */
+	struct kobject kobj;
+	struct mutex sysfs_lock;
+	struct ufshid_sysfs_entry *sysfs_entries;
+
+	/* for debug */
+	bool hid_debug;
+#if defined(CONFIG_UFSHID_POC)
+	bool block_suspend;
+#endif
+#if defined(CONFIG_UFSHID_DEBUG)
+	u64 read_cnt;
+	u64 write_cnt;
+	u64 read_sec;
+	u64 write_sec;
+	u64 write_query_cnt;
+#endif
+};
+
+struct ufshid_sysfs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct ufshid_dev *hid, char *buf);
+	ssize_t (*store)(struct ufshid_dev *hid, const char *buf, size_t count);
+};
+
+struct ufshcd_lrb;
+
+int ufshid_trigger_on(struct ufshid_dev *hid);
+int ufshid_trigger_off(struct ufshid_dev *hid);
+
+int ufshid_get_state(struct ufsf_feature *ufsf);
+void ufshid_set_state(struct ufsf_feature *ufsf, int state);
+void ufshid_get_dev_info(struct ufsf_feature *ufsf, u8 *desc_buf);
+void ufshid_set_init_state(struct ufsf_feature *ufsf);
+void ufshid_init(struct ufsf_feature *ufsf);
+void ufshid_reset(struct ufsf_feature *ufsf);
+void ufshid_reset_host(struct ufsf_feature *ufsf);
+void ufshid_remove(struct ufsf_feature *ufsf);
+void ufshid_suspend(struct ufsf_feature *ufsf);
+void ufshid_resume(struct ufsf_feature *ufsf);
+void ufshid_on_idle(struct ufsf_feature *ufsf);
+void ufshid_acc_io_stat_during_trigger(struct ufsf_feature *ufsf,
+				       struct ufshcd_lrb *lrbp);
+#endif /* End of Header */
diff --git a/drivers/scsi/ufs/vendor/ufssid.c b/drivers/scsi/ufs/vendor/ufssid.c
new file mode 100644
index 0000000000000..42f8ab5095946
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufssid.c
@@ -0,0 +1,292 @@
+/*
+ * Universal Flash Storage Stream ID (UFS SID)
+ *
+ * Copyright (C) 2021 Samsung Electronics Co., Ltd.
+ *
+ * Author:
+ *	Keoseong Park <keosung.park@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ *
+ * The Linux Foundation chooses to take subject only to the GPLv2
+ * license terms, and distributes only under these terms.
+ */
+
+#include "ufshcd.h"
+#include "ufsfeature.h"
+#include "ufssid.h"
+
+static int ufssid_create_sysfs(struct ufssid_dev *sid);
+
+static inline int ufssid_version_check(int spec_version)
+{
+	INFO_MSG("Support SID Spec: Driver = (%.4x), Device = (%.4x)",
+		 UFSSID_VER, spec_version);
+	INFO_MSG("SID Driver version (%.6X%s)",
+		 UFSSID_DD_VER, UFSSID_DD_VER_POST);
+
+	if (spec_version != UFSSID_VER) {
+		ERR_MSG("UFS SID version mismatched");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+void ufssid_get_dev_info(struct ufsf_feature *ufsf, u8 *desc_buf)
+{
+	int spec_version, ret = 0;
+
+	if (!(get_unaligned_be32(&desc_buf[DEVICE_DESC_PARAM_SAMSUNG_SUP]) &
+	    UFS_FEATURE_SUPPORT_SID_BIT)) {
+		INFO_MSG("bUFSExFeaturesSupport: SID not support");
+		return;
+	}
+
+	INFO_MSG("bUFSExFeaturesSupport: SID support");
+
+	spec_version = get_unaligned_be16(&desc_buf[DEVICE_DESC_PARAM_SID_VER]);
+	ret = ufssid_version_check(spec_version);
+	if (ret)
+		return;
+
+	ufsf->sid_dev = kzalloc(sizeof(struct ufssid_dev), GFP_KERNEL);
+	if (!ufsf->sid_dev) {
+		ERR_MSG("sid_dev memory allocation failed");
+		return;
+	}
+
+	ufsf->sid_dev->ufsf = ufsf;
+}
+
+void ufssid_prep_fn(struct ufsf_feature *ufsf, struct ufshcd_lrb *lrbp)
+{
+	struct ufssid_dev *sid = ufsf->sid_dev;
+	struct scsi_cmnd *cmd = lrbp->cmd;
+	struct request *request = scsi_cmd_to_rq(cmd);
+
+	if (sid->stream_id_enabled && request->bio) {
+		if (cmd->cmnd[0] == WRITE_10)
+			cmd->cmnd[6] = request->bio->bi_write_hint;
+		if (cmd->cmnd[0] == WRITE_16)
+			cmd->cmnd[14] = request->bio->bi_write_hint;
+	}
+}
+
+void ufssid_init(struct ufsf_feature *ufsf)
+{
+	struct ufssid_dev *sid;
+	int ret;
+
+	sid = ufsf->sid_dev;
+	if (!sid) {
+		ERR_MSG("sid is NULL. so SID driver is DISABLED");
+		return;
+	}
+
+	ret = ufshcd_query_flag_retry(ufsf->hba, UPIU_QUERY_OPCODE_READ_FLAG,
+				      QUERY_FLAG_IDN_STREAM_ID_EN, 0,
+				      &sid->stream_id_enabled);
+	if (ret) {
+		sid->stream_id_enabled = false;
+		ERR_MSG("Read query failed. So Stream ID is not enabled");
+	}
+
+	INFO_MSG("Stream ID is %s",
+		 sid->stream_id_enabled ? "ENABLED" : "DISABLED");
+
+	ret = ufssid_create_sysfs(sid);
+	if (ret) {
+		ERR_MSG("sysfs init failed. So SID driver is DISABLED");
+		kfree(sid);
+		return;
+	}
+
+	INFO_MSG("UFS SID create sysfs finished");
+}
+
+static inline void ufssid_remove_sysfs(struct ufssid_dev *sid)
+{
+	int ret;
+
+	ret = kobject_uevent(&sid->kobj, KOBJ_REMOVE);
+	INFO_MSG("kobject remove (%d)", ret);
+	kobject_del(&sid->kobj);
+}
+
+void ufssid_remove(struct ufsf_feature *ufsf)
+{
+	struct ufssid_dev *sid = ufsf->sid_dev;
+
+	INFO_MSG("Start SID release");
+
+	ufssid_remove_sysfs(sid);
+
+	kfree(sid);
+
+	INFO_MSG("End SID release");
+}
+
+static ssize_t ufssid_sysfs_show_stream_id_enabled(struct ufssid_dev *sid,
+						   char *buf)
+{
+	INFO_MSG("stream_id_enabled %d", sid->stream_id_enabled);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", sid->stream_id_enabled);
+}
+
+static ssize_t ufssid_sysfs_store_stream_id_enabled(struct ufssid_dev *sid,
+						    const char *buf,
+						    size_t count)
+{
+	struct ufs_hba *hba = sid->ufsf->hba;
+	unsigned long value;
+	int ret;
+	enum query_opcode opcode;
+
+	if (kstrtoul(buf, 0, &value))
+		return -EINVAL;
+
+	if (!(value == 0 || value == 1))
+		return -EINVAL;
+
+	if (value == sid->stream_id_enabled)
+		goto out;
+
+	opcode = value ?
+		UPIU_QUERY_OPCODE_SET_FLAG : UPIU_QUERY_OPCODE_CLEAR_FLAG;
+
+	pm_runtime_get_sync(hba->dev);
+	ret = ufshcd_query_flag(hba, opcode, QUERY_FLAG_IDN_STREAM_ID_EN, 0,
+				NULL);
+	pm_runtime_put_sync(hba->dev);
+	if (ret)
+		return -EINVAL;
+
+	sid->stream_id_enabled = value ? true : false;
+
+out:
+	INFO_MSG("stream_id_enabled %d", sid->stream_id_enabled);
+
+	return count;
+}
+
+static struct ufssid_sysfs_entry ufssid_sysfs_entries[] = {
+	/* Flag */
+	__ATTR(stream_id_enabled, 0644,
+	       ufssid_sysfs_show_stream_id_enabled,
+	       ufssid_sysfs_store_stream_id_enabled),
+	__ATTR_NULL
+};
+
+static ssize_t ufssid_attr_show(struct kobject *kobj, struct attribute *attr,
+				char *page)
+{
+	struct ufssid_sysfs_entry *entry;
+	struct ufssid_dev *sid;
+	ssize_t error;
+
+	entry = container_of(attr, struct ufssid_sysfs_entry, attr);
+	if (!entry->show)
+		return -EIO;
+
+	sid = container_of(kobj, struct ufssid_dev, kobj);
+
+	mutex_lock(&sid->sysfs_lock);
+	error = entry->show(sid, page);
+	mutex_unlock(&sid->sysfs_lock);
+	return error;
+}
+
+static ssize_t ufssid_attr_store(struct kobject *kobj, struct attribute *attr,
+				 const char *page, size_t length)
+{
+	struct ufssid_sysfs_entry *entry;
+	struct ufssid_dev *sid;
+	ssize_t error;
+
+	entry = container_of(attr, struct ufssid_sysfs_entry, attr);
+	if (!entry->store)
+		return -EIO;
+
+	sid = container_of(kobj, struct ufssid_dev, kobj);
+
+	mutex_lock(&sid->sysfs_lock);
+	error = entry->store(sid, page, length);
+	mutex_unlock(&sid->sysfs_lock);
+	return error;
+}
+
+static const struct sysfs_ops ufssid_sysfs_ops = {
+	.show = ufssid_attr_show,
+	.store = ufssid_attr_store,
+};
+
+static struct kobj_type ufssid_ktype = {
+	.sysfs_ops = &ufssid_sysfs_ops,
+	.release = NULL,
+};
+
+static int ufssid_create_sysfs(struct ufssid_dev *sid)
+{
+	struct device *dev = sid->ufsf->hba->dev;
+	struct ufssid_sysfs_entry *entry;
+	int err;
+
+	sid->sysfs_entries = ufssid_sysfs_entries;
+
+	kobject_init(&sid->kobj, &ufssid_ktype);
+	mutex_init(&sid->sysfs_lock);
+
+	INFO_MSG("ufssid creates sysfs ufssid %p dev->kobj %p",
+		 &sid->kobj, &dev->kobj);
+
+	err = kobject_add(&sid->kobj, kobject_get(&dev->kobj), "ufssid");
+	if (!err) {
+		for (entry = sid->sysfs_entries; entry->attr.name != NULL;
+		     entry++) {
+			INFO_MSG("ufssid sysfs attr creates: %s",
+				 entry->attr.name);
+			err = sysfs_create_file(&sid->kobj, &entry->attr);
+			if (err) {
+				ERR_MSG("create entry(%s) failed",
+					entry->attr.name);
+				goto kobj_del;
+			}
+		}
+		kobject_uevent(&sid->kobj, KOBJ_ADD);
+	} else {
+		ERR_MSG("kobject_add failed");
+	}
+
+	return err;
+kobj_del:
+	err = kobject_uevent(&sid->kobj, KOBJ_REMOVE);
+	INFO_MSG("kobject removed (%d)", err);
+	kobject_del(&sid->kobj);
+	return -EINVAL;
+}
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/scsi/ufs/vendor/ufssid.h b/drivers/scsi/ufs/vendor/ufssid.h
new file mode 100644
index 0000000000000..e75df68a1a85e
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufssid.h
@@ -0,0 +1,69 @@
+/*
+ * Universal Flash Storage Stream ID (UFS SID)
+ *
+ * Copyright (C) 2021 Samsung Electronics Co., Ltd.
+ *
+ * Author:
+ *	Keoseong Park <keosung.park@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ *
+ * The Linux Foundation chooses to take subject only to the GPLv2
+ * license terms, and distributes only under these terms.
+ */
+
+#ifndef _UFSSID_H_
+#define _UFSSID_H_
+
+#define UFSSID_VER					0x0201
+#define UFSSID_DD_VER					0x010400
+#define UFSSID_DD_VER_POST				""
+
+#define UFS_FEATURE_SUPPORT_SID_BIT			(1 << 4)
+
+struct ufssid_dev {
+	struct ufsf_feature *ufsf;
+
+	bool stream_id_enabled;
+
+	/* For sysfs */
+	struct kobject kobj;
+	struct mutex sysfs_lock;
+	struct ufssid_sysfs_entry *sysfs_entries;
+};
+
+struct ufssid_sysfs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct ufssid_dev *sid, char *buf);
+	ssize_t (*store)(struct ufssid_dev *sid, const char *buf, size_t count);
+};
+
+struct ufshcd_lrb;
+
+void ufssid_get_dev_info(struct ufsf_feature *ufsf, u8 *desc_buf);
+void ufssid_prep_fn(struct ufsf_feature *ufsf, struct ufshcd_lrb *lrbp);
+void ufssid_init(struct ufsf_feature *ufsf);
+void ufssid_remove(struct ufsf_feature *ufsf);
+#endif /* End of Header */
