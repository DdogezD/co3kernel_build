From 61e5641ac01bf8a1544f1678e9644d9e976df7c3 Mon Sep 17 00:00:00 2001
From: William Liu <a17671@motorola.com>
Date: Mon, 30 Oct 2023 23:37:09 +0800
Subject: [PATCH] scsi/ufs: Add support for HID1.1 feature

The baseline only supports HID2.0 with the latest UFS from Samsung/Kioxia
Add legacy HID1.1 support for old version UFS from Samsung/Micron

Change-Id: Ibadba98fbeae4b6cdd136bea158f6e0163b22047
Signed-off-by: William Liu <a17671@motorola.com>
Reviewed-on: https://gerrit.mot.com/2780928
SME-Granted: SME Approvals Granted
SLTApproved: Slta Waiver
Tested-by: Jira Key
Reviewed-by: Chuanchun Zhu <zhucc2@motorola.com>
Reviewed-by: Xiangpo Zhao <zhaoxp3@motorola.com>
Submit-Approved: Jira Key
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 drivers/scsi/ufs/Kconfig             |  9 ++-
 drivers/scsi/ufs/vendor/ufsfeature.c | 18 ++++--
 drivers/scsi/ufs/vendor/ufsfeature.h | 25 ++++++++
 drivers/scsi/ufs/vendor/ufshid.c     | 85 +++++++++++++++++++++++-----
 drivers/scsi/ufs/vendor/ufshid.h     | 24 +++++++-
 5 files changed, 139 insertions(+), 22 deletions(-)

diff --git a/drivers/scsi/ufs/Kconfig b/drivers/scsi/ufs/Kconfig
index 0aa2ff3dc166..e5a8e7b8e963 100644
--- a/drivers/scsi/ufs/Kconfig
+++ b/drivers/scsi/ufs/Kconfig
@@ -235,6 +235,13 @@ config UFSFEATURE
 	help
 	  UFS feature activate such as hpb, tw and etc.
 
+config UFSFEATURE3
+	bool "UFS 3.1 features"
+	depends on SCSI_UFSHCD
+	default n
+	help
+	   UFS 3.1 features like HID
+
 config UFSHID
 	bool "UFS Host Initiated Defrag support"
 	depends on SCSI_UFSHCD && UFSFEATURE
@@ -275,4 +282,4 @@ config UFSFBO_POC
         depends on SCSI_UFSHCD && UFSFEATURE && UFSFBO
         default n
         help
-          UFS FBO POC test
\ No newline at end of file
+          UFS FBO POC test
diff --git a/drivers/scsi/ufs/vendor/ufsfeature.c b/drivers/scsi/ufs/vendor/ufsfeature.c
index b8d9a38a1e3f..f7ba0fe68b82 100644
--- a/drivers/scsi/ufs/vendor/ufsfeature.c
+++ b/drivers/scsi/ufs/vendor/ufsfeature.c
@@ -47,11 +47,15 @@ static int ufsf_read_desc(struct ufs_hba *hba, u8 desc_id, u8 desc_index,
 			  u8 *desc_buf, u32 size)
 {
 	int err = 0;
-
+	u8 selector =0;
+#if defined(CONFIG_UFSFEATURE3)
+	if (is_vendor_device(hba, UFS_VENDOR_SAMSUNG))
+		selector = 1;
+#endif
 	pm_runtime_get_sync(hba->dev);
 
 	err = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_READ_DESC,
-					    desc_id, desc_index, 0,
+					    desc_id, desc_index, selector,
 					    desc_buf, &size);
 	if (err)
 		ERR_MSG("reading Device Desc failed. err = %d", err);
@@ -69,7 +73,6 @@ static int ufsf_read_dev_desc(struct ufsf_feature *ufsf)
 
 	if (is_vendor_device(ufsf->hba, UFS_VENDOR_SAMSUNG))
 		idn = UFSF_QUERY_DESC_IDN_DEVICE;
-
 	ret = ufsf_read_desc(ufsf->hba, idn, 0,
 			     desc_buf, UFSF_QUERY_DESC_DEVICE_MAX_SIZE);
 	if (ret)
@@ -104,7 +107,7 @@ static int ufsf_read_dev_desc(struct ufsf_feature *ufsf)
 #endif
 	return 0;
 }
-
+#if !defined(CONFIG_UFSFEATURE3)
 static int ufsf_read_geo_desc(struct ufsf_feature *ufsf)
 {
 	u8 geo_buf[UFSF_QUERY_DESC_GEOMETRY_MAX_SIZE];
@@ -126,7 +129,7 @@ static int ufsf_read_geo_desc(struct ufsf_feature *ufsf)
 
 	return 0;
 }
-
+#endif
 void ufsf_device_check(struct ufs_hba *hba)
 {
 	struct ufsf_feature *ufsf = ufs_qcom_get_ufsf(hba);
@@ -137,7 +140,9 @@ void ufsf_device_check(struct ufs_hba *hba)
 #if defined(CONFIG_UFSFBO)
 	ufsfbo_read_fbo_desc(ufsf);
 #endif
+#if !defined(CONFIG_UFSFEATURE3)
 	ufsf_read_geo_desc(ufsf);
+#endif
 }
 
 static int ufsf_execute_dev_ctx_req(struct ufsf_feature *ufsf,
@@ -301,9 +306,10 @@ int ufsf_query_ioctl(struct ufsf_feature *ufsf, int lun, void __user *buffer,
 		case QUERY_DESC_IDN_DEVICE:
 		case QUERY_DESC_IDN_GEOMETRY:
 		case QUERY_DESC_IDN_CONFIGURATION:
+#if !defined(CONFIG_UFSFEATURE3)
 		case UFSF_QUERY_DESC_IDN_DEVICE:
 		case UFSF_QUERY_DESC_IDN_GEOMETRY:
-
+#endif
 			break;
 
 		default:
diff --git a/drivers/scsi/ufs/vendor/ufsfeature.h b/drivers/scsi/ufs/vendor/ufsfeature.h
index 92df8c4c8524..b10985522170 100644
--- a/drivers/scsi/ufs/vendor/ufsfeature.h
+++ b/drivers/scsi/ufs/vendor/ufsfeature.h
@@ -97,8 +97,14 @@ enum {
 #define UFSF_QUERY_DESC_FBO_MAX_SIZE		0x12
 
 /* Descriptor idn for Query Request */
+#if !defined(CONFIG_UFSFEATURE3)
 #define UFSF_QUERY_DESC_IDN_DEVICE		0xF0
 #define UFSF_QUERY_DESC_IDN_GEOMETRY		0xF7
+#else
+#define UFSF_QUERY_DESC_IDN_DEVICE          0
+#define UFSF_QUERY_DESC_IDN_GEOMETRY		7
+#endif
+
 
 #define UFSF_QUERY_DESC_IDN_FBO			0x0A
 /* query_flag  */
@@ -192,15 +198,34 @@ void ufsf_hid_acc_io_stat(struct ufsf_feature *ufsf, struct ufshcd_lrb *lrbp);
 
 /* Attribute idn for Query requests */
 #if defined(CONFIG_UFSHID)
+#if !defined(CONFIG_UFSFEATURE3)
 #define QUERY_ATTR_IDN_HID_OPERATION			0x80
 #define QUERY_ATTR_IDN_HID_FRAG_LEVEL			0x81
+#else
+#define QUERY_ATTR_IDN_HID_OPERATION			0x20
+#define QUERY_ATTR_IDN_HID_FRAG_LEVEL			0x21
+#endif
+#endif
+
+#if defined(CONFIG_UFSFEATURE3)
+#define	QUERY_FLAG_IDN_HID_EN					0x13
+#define	QUERY_ATTR_IDN_HID_FRAG_STATUS        0x31
+#define	QUERY_ATTR_IDN_HID_PROGRESS        0x32
 #endif
 
 /* Device descriptor parameters offsets in bytes*/
 #define DEVICE_DESC_PARAM_EX_FEAT_SUP			0x4F
+#if !defined(CONFIG_UFSFEATURE3)
 #define DEVICE_DESC_PARAM_SAMSUNG_SUP			0xFB
+#else
+#define DEVICE_DESC_PARAM_SAMSUNG_SUP			0x4F
+#endif
 #if defined(CONFIG_UFSHID)
+#if !defined(CONFIG_UFSFEATURE3)
 #define DEVICE_DESC_PARAM_HID_VER			0xF7
+#else
+#define DEVICE_DESC_PARAM_HID_VER			0x59
+#endif
 #endif
 #if defined(CONFIG_UFSSID)
 #define DEVICE_DESC_PARAM_SID_VER			0xEF
diff --git a/drivers/scsi/ufs/vendor/ufshid.c b/drivers/scsi/ufs/vendor/ufshid.c
index f745b80e538a..81b83703544d 100644
--- a/drivers/scsi/ufs/vendor/ufshid.c
+++ b/drivers/scsi/ufs/vendor/ufshid.c
@@ -141,11 +141,16 @@ static int ufshid_read_attr(struct ufshid_dev *hid, u8 idn, u32 *attr_val)
 {
 	struct ufs_hba *hba = hid->ufsf->hba;
 	int ret = 0;
+	int selector = 0;
 
 	ufshcd_rpm_get_sync(hba);
-
+#if defined(CONFIG_UFSFEATURE3)
+	if (is_vendor_device(hba,UFS_VENDOR_SAMSUNG)){
+		selector = 1;
+	}
+#endif
 	ret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR, idn, 0,
-				      0, attr_val);
+				      selector, attr_val);
 	if (ret) {
 		ERR_MSG("read attr [0x%.2X] fail. (%d)", idn, ret);
 		goto err_out;
@@ -166,11 +171,16 @@ static int ufshid_write_attr(struct ufshid_dev *hid, u8 idn, u32 val)
 {
 	struct ufs_hba *hba = hid->ufsf->hba;
 	int ret = 0;
+	int selector = 0;
 
 	ufshcd_rpm_get_sync(hba);
-
+#if defined(CONFIG_UFSFEATURE3)
+	if (is_vendor_device(hba,UFS_VENDOR_SAMSUNG)){
+		selector = 1;
+	}
+#endif
 	ret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_WRITE_ATTR, idn, 0,
-				      0, &val);
+				      selector, &val);
 	if (ret) {
 		ERR_MSG("write attr [0x%.2X] fail. (%d)", idn, ret);
 		goto err_out;
@@ -247,7 +257,7 @@ void ufshid_get_dev_info(struct ufsf_feature *ufsf, u8 *desc_buf)
 err_out:
 	ufshid_set_state(ufsf, HID_FAILED);
 }
-
+#if !defined(CONFIG_UFSFEATURE3)
 static inline void ufshid_set_wb_cmd(unsigned char *cdb, size_t len)
 {
 	cdb[0] = WRITE_BUFFER;
@@ -347,7 +357,7 @@ static int ufshid_wait_hid_req(struct ufshid_dev *hid)
 	}
 	return 0;
 }
-
+#endif
 static inline void ufshid_init_lba_trigger_mode(struct ufshid_dev *hid)
 {
 	hid->lba_trigger_mode = false;
@@ -371,15 +381,17 @@ static inline void ufshid_set_lba_trigger_mode(struct ufshid_dev *hid,
 
 static inline void ufshid_clear_lba_trigger_mode(struct ufshid_dev *hid)
 {
+#if !defined(CONFIG_UFSFEATURE3)
 	if (!ufshid_wait_hid_req(hid))
 		ufshid_init_lba_trigger_mode(hid);
+#endif
 }
 
 static int ufshid_execute_query_op(struct ufshid_dev *hid, enum UFSHID_OP op,
 				   u32 *attr_val)
 {
+#if !defined(CONFIG_UFSFEATURE3)
 	int ret;
-
 	ret = ufshid_wait_hid_req(hid);
 	if (ret)
 		return -EBUSY;
@@ -387,7 +399,7 @@ static int ufshid_execute_query_op(struct ufshid_dev *hid, enum UFSHID_OP op,
 	ret = ufshid_issue_lba_list(hid);
 	if (ret)
 		return ret;
-
+#endif
 	if (ufshid_write_attr(hid, QUERY_ATTR_IDN_HID_OPERATION, op))
 		return -EINVAL;
 
@@ -433,7 +445,30 @@ static int ufshid_get_analyze_and_issue_execute(struct ufshid_dev *hid)
 	int ret;
     struct ufsf_feature *ufsf = hid->ufsf;
 
-	if (is_vendor_device(ufsf->hba,UFS_VENDOR_SAMSUNG)) {
+	if (is_vendor_device(ufsf->hba,UFS_VENDOR_MICRON)) {
+#if defined(CONFIG_UFSFEATURE3)
+		//get micron ufs frag level
+		if (ufshid_read_attr(hid, QUERY_ATTR_IDN_HID_FRAG_STATUS, &frag_level))
+			return -EINVAL;
+		//get micron ufs hid execution progress
+		if (ufshid_read_attr(hid, QUERY_ATTR_IDN_HID_PROGRESS, &attr_val))
+			return -EINVAL;
+		HID_DEBUG(hid, "micron frag_level= %d attr_val= %d",frag_level,attr_val);
+
+		if (attr_val != HID_PROG_ONGOING) {
+			if(frag_level!= HID_LEV_GREEN_MICRON) {
+				ufshid_set_flag(hid, QUERY_FLAG_IDN_HID_EN);
+				return HID_REQUIRED;
+			} else {
+				return HID_NOT_REQUIRED;
+			}
+		} else {
+			return HID_REQUIRED;
+		}
+#else
+	return -EAGAIN;
+#endif
+	} else if (is_vendor_device(ufsf->hba,UFS_VENDOR_SAMSUNG)) {
 		ret = ufshid_execute_query_op(hid, HID_OP_EXECUTE, &attr_val);
 		if (ret)
 			return ret;
@@ -486,7 +521,19 @@ static inline void ufshid_issue_disable(struct ufshid_dev *hid)
 		ERR_MSG("the ufsf is NULL !!!");
 		return;
 	}
-    if (is_vendor_device(ufsf->hba,UFS_VENDOR_SAMSUNG)) {
+	if (is_vendor_device(ufsf->hba, UFS_VENDOR_MICRON)) {
+#if defined(CONFIG_UFSFEATURE3)
+		//get micron ufs hid execution progress
+		if (ufshid_read_attr(hid, QUERY_ATTR_IDN_HID_PROGRESS, &attr_val))
+			return ;
+		HID_DEBUG(hid, "micron hid progress = %d",attr_val);
+
+		if(attr_val == HID_PROG_ONGOING) {
+			if (ufshid_clear_flag(hid, QUERY_FLAG_IDN_HID_EN))
+				return ;
+		}
+#endif
+	}else if (is_vendor_device(ufsf->hba,UFS_VENDOR_SAMSUNG)) {
 		ufshid_execute_query_op(hid, HID_OP_DISABLE, &attr_val);
 	}else if(is_vendor_device(ufsf->hba,UFS_VENDOR_TOSHIBA)){
        if (ufshid_clear_flag(hid, QUERY_FLAG_IDN_WB_BUFF_FLUSH_EN))
@@ -1028,11 +1075,11 @@ void ufshid_remove(struct ufsf_feature *ufsf)
 	mutex_unlock(&hid->sysfs_lock);
 
 	cancel_delayed_work_sync(&hid->hid_trigger_work);
-
+#if !defined(CONFIG_UFSFEATURE3)
 	ret = ufshid_wait_hid_req(hid);
 	if (ret)
 		ERR_MSG("hid req is not completed");
-
+#endif
 	kfree(hid);
 
 	INFO_MSG("end HID release");
@@ -1234,7 +1281,19 @@ static ssize_t ufshid_sysfs_show_color(struct ufshid_dev *hid, char *buf)
 		return -EINVAL;
 	}
 
-	if (is_vendor_device(ufsf->hba,  UFS_VENDOR_SAMSUNG)) {
+	if (is_vendor_device(ufsf->hba, UFS_VENDOR_MICRON)) {
+#if defined(CONFIG_UFSFEATURE3)
+		if (ufshid_read_attr(hid, QUERY_ATTR_IDN_HID_FRAG_STATUS, &attr_val))
+			return -EINVAL;
+		frag_level = attr_val;
+			/*Micron only has two levels RED & GREEN*/
+		return snprintf(buf, PAGE_SIZE, "%s\n",
+			((frag_level == HID_LEV_GREEN_MICRON)) ? "GREEN" :
+			((frag_level ==HID_LEV_RED_MICRON))?"RED":"UNKNOWN");
+#else
+	return snprintf(buf, PAGE_SIZE, "%s\n","Error.");
+#endif
+	} else if (is_vendor_device(ufsf->hba,  UFS_VENDOR_SAMSUNG)) {
 		ret = ufshid_execute_query_op(hid, HID_OP_ANALYZE, &attr_val);
 		if (ret)
 			return ret;
diff --git a/drivers/scsi/ufs/vendor/ufshid.h b/drivers/scsi/ufs/vendor/ufshid.h
index 592128c2829a..1e5225fc800f 100644
--- a/drivers/scsi/ufs/vendor/ufshid.h
+++ b/drivers/scsi/ufs/vendor/ufshid.h
@@ -46,12 +46,20 @@
 #include <scsi/scsi_cmnd.h>
 
 #include "../../../block/blk.h"
-
+#if  !defined(CONFIG_UFSFEATURE3)
 #define UFSHID_VER					0x0201
+#else
+#define UFSHID_VER					0x0101
+#endif
 #define UFSHID_DD_VER					0x020200
 #define UFSHID_DD_VER_POST				""
-
+#if  !defined(CONFIG_UFSFEATURE3)
 #define UFS_FEATURE_SUPPORT_HID_BIT			(1 << 0)
+#else
+#define UFS_FEATURE_SUPPORT_HID_BIT			(0x400)
+#endif
+
+
 
 #define HID_TRIGGER_WORKER_DELAY_MS_DEFAULT	2000
 #define HID_TRIGGER_WORKER_DELAY_MS_MIN		100
@@ -106,6 +114,18 @@ enum {
 	HID_REQUIRED		= 1
 };
 
+ enum {
+	HID_LEV_GREEN_MICRON  = 0,
+	HID_LEV_RED_MICRON   = 1,
+ };
+
+enum {
+	HID_PROG_IDLE		= 0,
+	HID_PROG_ONGOING	= 1,
+	HID_PROG_STOP	= 2, //stopped by Host
+	HID_PROG_COMPLETE	= 3,
+ };
+
 enum {
 	HID_LEV_GRAY	= 0,
 	HID_LEV_GREEN	= 1,
