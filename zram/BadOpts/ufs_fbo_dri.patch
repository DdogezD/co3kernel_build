From 440e8d621ee1299a8ad5bf7e245752ea0cc9da40 Mon Sep 17 00:00:00 2001
From: yuedl1 <yuedl1@lenovo.com>
Date: Sun, 9 Oct 2022 20:44:57 +0800
Subject: [PATCH] scsi/ufs: Porting samsung ufs FBO feature driver

File based optimizations is shorted FBO, it is a method in which the
host provide the storage device file system information in order to
improve the performance regression.  samsung UFS support FBO feature
on 8550,the driver is from samsung vendor.

Change-Id: I87173d352cbafb851a2f343aa2f205a2eac7d709
Signed-off-by: yuedl1 <yuedl1@lenovo.com>
Reviewed-on: https://gerrit.mot.com/2399633
SME-Granted: SME Approvals Granted
SLTApproved: Slta Waiver
Tested-by: Jira Key
Reviewed-by: Zhenxin Xi <xizx@motorola.com>
Submit-Approved: Jira Key
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 drivers/scsi/ufs/Kconfig             |   13 +
 drivers/scsi/ufs/Makefile            |    1 +
 drivers/scsi/ufs/ufs-qcom.c          |    8 +
 drivers/scsi/ufs/vendor/ufsfbo.c     | 1386 ++++++++++++++++++++++++++
 drivers/scsi/ufs/vendor/ufsfbo.h     |  201 ++++
 drivers/scsi/ufs/vendor/ufsfeature.c |   95 +-
 drivers/scsi/ufs/vendor/ufsfeature.h |   27 +
 7 files changed, 1728 insertions(+), 3 deletions(-)
 create mode 100644 drivers/scsi/ufs/vendor/ufsfbo.c
 create mode 100644 drivers/scsi/ufs/vendor/ufsfbo.h

diff --git a/drivers/scsi/ufs/Kconfig b/drivers/scsi/ufs/Kconfig
index df4699d7437a..0aa2ff3dc166 100644
--- a/drivers/scsi/ufs/Kconfig
+++ b/drivers/scsi/ufs/Kconfig
@@ -263,3 +263,16 @@ config UFSSID
 	depends on SCSI_UFSHCD && UFSFEATURE && UFSHID
 	help
 	  Enable Stream ID Feature for Streamed-HID
+
+config UFSFBO
+        bool "UFS File Base Optimization support"
+        depends on SCSI_UFSHCD && UFSFEATURE
+        help
+          Enable UFS FBO Feature
+
+config UFSFBO_POC
+        bool "UFSFBO_POC test"
+        depends on SCSI_UFSHCD && UFSFEATURE && UFSFBO
+        default n
+        help
+          UFS FBO POC test
\ No newline at end of file
diff --git a/drivers/scsi/ufs/Makefile b/drivers/scsi/ufs/Makefile
index d0b08ceb26ea..ecef550eab82 100644
--- a/drivers/scsi/ufs/Makefile
+++ b/drivers/scsi/ufs/Makefile
@@ -22,6 +22,7 @@ ufs_qcom-y += ufs-qcom.o
 ufs_qcom-$(CONFIG_UFSFEATURE) += vendor/ufsfeature.o vendor/ufsfeature-mimic.o
 ufs_qcom-$(CONFIG_UFSHID) += vendor/ufshid.o
 ufs_qcom-$(CONFIG_UFSSID) += vendor/ufssid.o
+ufs_qcom-$(CONFIG_UFSFBO) += vendor/ufsfbo.o
 ufs_qcom-$(CONFIG_SCSI_UFS_CRYPTO) += ufs-qcom-ice.o
 obj-$(CONFIG_SCSI_UFS_EXYNOS) += ufs-exynos.o
 obj-$(CONFIG_SCSI_UFSHCD_PCI) += ufshcd-pci.o
diff --git a/drivers/scsi/ufs/ufs-qcom.c b/drivers/scsi/ufs/ufs-qcom.c
index 89cc0d184bf1..528956474767 100644
--- a/drivers/scsi/ufs/ufs-qcom.c
+++ b/drivers/scsi/ufs/ufs-qcom.c
@@ -2720,6 +2720,14 @@ ufs_qcom_query_ioctl(struct ufs_hba *hba, u8 lun, void __user *buffer)
 			__func__, err);
 		goto out_release_mem;
 	}
+#if defined(CONFIG_UFSFEATURE)
+        if (ufsf_check_query(ioctl_data->opcode)) {
+                err = ufsf_query_ioctl(ufs_qcom_get_ufsf(hba), lun, buffer,
+                                       ioctl_data);
+                goto out_release_mem;
+        }
+#endif
+
 
 	/* verify legal parameters & send query */
 	switch (ioctl_data->opcode) {
diff --git a/drivers/scsi/ufs/vendor/ufsfbo.c b/drivers/scsi/ufs/vendor/ufsfbo.c
new file mode 100644
index 000000000000..a3408f8be0dd
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufsfbo.c
@@ -0,0 +1,1386 @@
+/*
+ * Universal Flash Storage File Base Optimization
+ *
+ * Copyright (C) 2022 Samsung Electronics Co., Ltd.
+ *
+ * Author:
+ *	Keoseong Park <keosung.park@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ *
+ * The Linux Foundation chooses to take subject only to the GPLv2
+ * license terms, and distributes only under these terms.
+ */
+
+#include "ufshcd.h"
+#include "ufsfeature.h"
+#include "ufsfbo.h"
+
+static int ufsfbo_create_sysfs(struct ufsfbo_dev *fbo);
+
+static inline void ufsfbo_rpm_put_noidle(struct ufs_hba *hba)
+{
+	pm_runtime_put_noidle(&hba->sdev_ufs_device->sdev_gendev);
+}
+
+inline int ufsfbo_get_state(struct ufsf_feature *ufsf)
+{
+	return atomic_read(&ufsf->fbo_state);
+}
+
+inline void ufsfbo_set_state(struct ufsf_feature *ufsf, int state)
+{
+	atomic_set(&ufsf->fbo_state, state);
+}
+
+static inline int ufsfbo_is_not_present(struct ufsfbo_dev *fbo)
+{
+	enum UFSFBO_STATE cur_state = ufsfbo_get_state(fbo->ufsf);
+
+	if (cur_state != FBO_PRESENT) {
+		INFO_MSG("fbo_state != FBO_PRESENT (%d)", cur_state);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int ufsfbo_write_attr(struct ufsfbo_dev *fbo, u8 idn, u32 val)
+{
+	struct ufs_hba *hba = fbo->ufsf->hba;
+	int ret;
+
+	ufshcd_rpm_get_sync(hba);
+
+	ret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_WRITE_ATTR, idn, 0,
+				      0, &val);
+
+	ufsfbo_rpm_put_noidle(hba);
+
+	if (ret)
+		ERR_MSG("write attr [0x%.2X] failed. (%d)", idn, ret);
+	else
+		FBO_DEBUG(fbo, "fbo_attr write [0x%.2X] %u (0x%X)", idn, val,
+			  val);
+
+	return ret;
+}
+
+static int ufsfbo_read_attr(struct ufsfbo_dev *fbo, u8 idn, u32 *val)
+{
+	struct ufs_hba *hba = fbo->ufsf->hba;
+	int ret;
+
+	ufshcd_rpm_get_sync(hba);
+
+	ret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR, idn, 0,
+				      0, val);
+
+	ufsfbo_rpm_put_noidle(hba);
+
+	if (ret)
+		ERR_MSG("read attr [0x%.2X] failed. (%d)", idn, ret);
+	else
+		FBO_DEBUG(fbo, "fbo_attr read [0x%.2X] %u (0x%X)", idn, *val,
+			  *val);
+
+	return ret;
+}
+
+static int ufsfbo_read_desc(struct ufs_hba *hba, u8 desc_id, u8 desc_index,
+			    u8 *desc_buf, int size)
+{
+	int ret;
+
+	pm_runtime_get_sync(hba->dev);
+
+	ret = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_READ_DESC,
+					    desc_id, desc_index, 0, desc_buf,
+					    &size);
+
+	pm_runtime_put_noidle(hba->dev);
+
+	if (ret)
+		ERR_MSG("Reading desc failed. (%d)", ret);
+
+	return ret;
+}
+
+static inline int ufsfbo_version_check(int spec_version)
+{
+	INFO_MSG("Support FBO Spec: Driver = (%.4x), Device = (%.4x)",
+		 UFSFBO_VER, spec_version);
+	INFO_MSG("FBO Driver version (%.6X%s)",
+		 UFSFBO_DD_VER, UFSFBO_DD_VER_POST);
+
+	if (spec_version != UFSFBO_VER) {
+		ERR_MSG("UFS FBO version mismatched");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+void ufsfbo_read_fbo_desc(struct ufsf_feature *ufsf)
+{
+	u8 desc_buf[UFSF_QUERY_DESC_FBO_MAX_SIZE];
+	struct ufsfbo_dev *fbo;
+	int ret, spec_version;
+
+	ufsf->fbo_dev = NULL;
+
+	if (!is_vendor_device(ufsf->hba, UFS_VENDOR_SAMSUNG)){
+		INFO_MSG("this fbo driver is not support");
+		return;
+	}
+
+	ret = ufsfbo_read_desc(ufsf->hba, UFSF_QUERY_DESC_IDN_FBO, 0, desc_buf,
+			       UFSF_QUERY_DESC_FBO_MAX_SIZE);
+	if (ret) {
+		ERR_MSG("reading FBO Desc failed. (%d)", ret);
+		goto err_out;
+	}
+
+	spec_version = get_unaligned_be16(desc_buf + FBO_DESC_PARAM_FBO_VERSION);
+	ret = ufsfbo_version_check(spec_version);
+	if (ret)
+		goto err_out;
+
+	ufsf->fbo_dev = kzalloc(sizeof(struct ufsfbo_dev), GFP_KERNEL);
+	if (!ufsf->fbo_dev) {
+		ERR_MSG("fbo_dev memalloc failed");
+		goto err_out;
+	}
+
+	fbo = ufsf->fbo_dev;
+
+	fbo->rec_lba_range_size = get_unaligned_be32(desc_buf +
+				FBO_DESC_PARAM_FBO_RECOMMENDED_LBA_RANGE_SIZE);
+	fbo->max_lba_range_size = get_unaligned_be32(desc_buf +
+					FBO_DESC_PARAM_FBO_MAX_LBA_RANGE_SIZE);
+	fbo->min_lba_range_size = get_unaligned_be32(desc_buf +
+					FBO_DESC_PARAM_FBO_MIN_LBA_RANGE_SIZE);
+	fbo->max_lba_range_count = desc_buf[FBO_DESC_PARAM_FBO_MAX_LBA_RANGE_COUNT];
+	fbo->lba_range_alignment = get_unaligned_be16(desc_buf +
+					FBO_DESC_PARAM_FBO_LBA_RANGE_ALIGNMENT);
+	INFO_MSG("[0x%.2x] dFBORecommendedLBARangeSize (%u)",
+		 FBO_DESC_PARAM_FBO_RECOMMENDED_LBA_RANGE_SIZE,
+		 fbo->rec_lba_range_size);
+	INFO_MSG("[0x%.2x] dFBOMaxLBARangeSize (%u)",
+		 FBO_DESC_PARAM_FBO_MAX_LBA_RANGE_SIZE,
+		 fbo->max_lba_range_size);
+	INFO_MSG("[0x%.2x] dFBOMinLBARangeSize (%u)",
+		 FBO_DESC_PARAM_FBO_MIN_LBA_RANGE_SIZE,
+		 fbo->min_lba_range_size);
+	INFO_MSG("[0x%.2x] dFBOMaxLBARangeCount (%u)",
+		 FBO_DESC_PARAM_FBO_MAX_LBA_RANGE_COUNT,
+		 fbo->max_lba_range_count);
+	INFO_MSG("[0x%.2x] wFBOLBARangeAlignment (%u)",
+		 FBO_DESC_PARAM_FBO_LBA_RANGE_ALIGNMENT,
+		 fbo->lba_range_alignment);
+
+	fbo->ufsf = ufsf;
+
+	return;
+err_out:
+	ufsfbo_set_state(ufsf, FBO_FAILED);
+}
+
+void ufsfbo_get_dev_info(struct ufsf_feature *ufsf)
+{
+	u8 desc_buf[QUERY_DESC_MAX_SIZE];
+	struct ufs_hba *hba = ufsf->hba;
+	int ret;
+
+	ret = ufsfbo_read_desc(hba, QUERY_DESC_IDN_DEVICE, 0, desc_buf,
+			       QUERY_DESC_MAX_SIZE);
+	if (ret) {
+		ERR_MSG("reading Device Desc failed. (%d)", ret);
+		goto err_out;
+	}
+
+	if (!(get_unaligned_be32(desc_buf + DEVICE_DESC_PARAM_EXT_UFS_FEATURE_SUP)
+	      & UFS_FEATURE_SUPPORT_FBO_BIT)) {
+		INFO_MSG("dExtendedUFSFeaturesSupport: FBO not support");
+		goto err_out;
+	}
+
+	INFO_MSG("dExtendedUFSFeaturesSupport: FBO support");
+
+	return;
+err_out:
+	ufsfbo_set_state(ufsf, FBO_FAILED);
+}
+
+static void ufsfbo_init_write_buffer(struct ufsfbo_dev *fbo, int lun,
+				     unsigned char *buf, __u16 size)
+{
+	struct ufsfbo_req *wb = &fbo->write_buffer;
+
+	wb->lun= lun;
+	memcpy(wb->buf, buf, size);
+	wb->buf_size = size;
+}
+
+static void ufsfbo_init_read_buffer(struct ufsfbo_dev *fbo, int lun,
+				    unsigned char *buf, __u16 size)
+{
+	struct ufsfbo_req *rb = &fbo->read_buffer;
+
+	rb->lun = lun;
+	rb->buf_size = size;
+}
+
+static inline void ufsfbo_init_buffers(struct ufsfbo_dev *fbo, int lun,
+				      unsigned char *buf,
+				      __u16 size)
+{
+	ufsfbo_init_write_buffer(fbo, lun, buf, size);
+	ufsfbo_init_read_buffer(fbo, lun, buf, size);
+}
+
+/*
+ * If the return value is not err, pm_runtime_put_noidle() must be called once.
+ * IMPORTANT : ufsfbo_hold_runtime_pm() & ufsfbo_release_runtime_pm() pair.
+ */
+static int ufsfbo_hold_runtime_pm(struct ufsfbo_dev *fbo)
+{
+	struct ufs_hba *hba = fbo->ufsf->hba;
+
+	if (ufsfbo_get_state(fbo->ufsf) == FBO_SUSPEND) {
+		/* Check that device was suspended by System PM */
+		ufshcd_rpm_get_sync(hba);
+
+		/*
+		 * Guaranteed that ufsf_resume() is completed
+		 */
+		down(&hba->host_sem);
+		up(&hba->host_sem);
+
+		/* If it success, device was suspended by Runtime PM */
+		if (ufsfbo_get_state(fbo->ufsf) == FBO_PRESENT &&
+		    hba->curr_dev_pwr_mode == UFS_ACTIVE_PWR_MODE &&
+		    hba->uic_link_state == UIC_LINK_ACTIVE_STATE)
+			goto resume_success;
+
+		INFO_MSG("RPM resume failed. Maybe it was SPM suspend");
+		INFO_MSG("UFS state (POWER = %d LINK = %d)",
+			 hba->curr_dev_pwr_mode, hba->uic_link_state);
+
+		ufsfbo_rpm_put_noidle(hba);
+		return -ENODEV;
+	}
+
+	if (ufsfbo_is_not_present(fbo))
+		return -ENODEV;
+
+	ufshcd_rpm_get_sync(hba);
+resume_success:
+	return 0;
+}
+
+static inline void ufsfbo_release_runtime_pm(struct ufsfbo_dev *fbo)
+{
+	struct ufs_hba *hba = fbo->ufsf->hba;
+
+	ufsfbo_rpm_put_noidle(hba);
+}
+
+static int __ufsfbo_issue_buffer(struct ufsfbo_dev *fbo, unsigned char *cdb,
+				 struct ufsfbo_req *fbo_req,
+				 enum dma_data_direction dir)
+{
+	struct ufsf_feature *ufsf = fbo->ufsf;
+	struct scsi_device *sdev;
+	struct scsi_sense_hdr sshdr;
+	int ret = 0, retries;
+
+	sdev = ufsf->sdev_ufs_lu[fbo_req->lun];
+	if (!sdev) {
+		ERR_MSG("cannot find scsi_device [%d]", fbo_req->lun);
+		return -ENODEV;
+	}
+
+	for (retries = 0; retries < 3; retries++) {
+		ret = scsi_execute(sdev, cdb, dir, fbo_req->buf,
+				   fbo_req->buf_size, NULL, &sshdr,
+				   msecs_to_jiffies(30000), 0, 0, RQF_QUIET,
+				   NULL);
+		if (ret)
+			ERR_MSG("%s for FBO failed. (%d) retries %d",
+				dir == DMA_TO_DEVICE ? "WB" : "RB", ret, retries);
+		else
+			break;
+	}
+
+	INFO_MSG("%s for FBO %s", dir == DMA_TO_DEVICE ? "WB" : "RB",
+		 ret ? "failed" : "success");
+
+	if (ret) {
+		ERR_MSG("code %x sense_key %x asc %x ascq %x",
+			sshdr.response_code,
+			sshdr.sense_key, sshdr.asc, sshdr.ascq);
+		ERR_MSG("byte4 %x byte5 %x byte6 %x additional_len %x",
+			sshdr.byte4, sshdr.byte5,
+			sshdr.byte6, sshdr.additional_length);
+	}
+
+	return ret;
+}
+
+static int ufsfbo_issue_write_buffer(struct ufsfbo_dev *fbo)
+{
+	struct ufsfbo_req *fbo_req = &fbo->write_buffer;
+	unsigned char cdb[10] = { 0 };
+	int ret;
+
+	if (!fbo_req->buf_size) {
+		ERR_MSG("buf_size is 0. check it (%lu)", fbo_req->buf_size);
+		return -EINVAL;
+	}
+
+	cdb[0] = WRITE_BUFFER;
+	cdb[1] = WRITE_BUFFER_DATA_MODE;
+	cdb[2] = WRITE_BUFFER_ID;
+	put_unaligned_be24(fbo_req->buf_size, cdb + 6);
+
+	ret = __ufsfbo_issue_buffer(fbo, cdb, fbo_req, DMA_TO_DEVICE);
+
+	return ret;
+}
+
+static int ufsfbo_issue_read_buffer(struct ufsfbo_dev *fbo)
+{
+	struct ufsfbo_req *fbo_req = &fbo->read_buffer;
+	unsigned char cdb[10] = { 0 };
+	int ret;
+
+	if (!fbo_req->buf_size) {
+		ERR_MSG("buf_size is 0. check it (%lu)", fbo_req->buf_size);
+		return -EINVAL;
+	}
+
+	cdb[0] = READ_BUFFER;
+	cdb[1] = READ_BUFFER_DATA_MODE;
+	cdb[2] = READ_BUFFER_ID;
+	put_unaligned_be24(fbo_req->buf_size, cdb + 6);
+
+	ret = __ufsfbo_issue_buffer(fbo, cdb, fbo_req, DMA_FROM_DEVICE);
+
+	return ret;
+}
+
+static inline int ufsfbo_check_progress_state(struct ufsfbo_dev *fbo,
+					      u32 *attr_val)
+{
+	if (ufsfbo_read_attr(fbo, QUERY_ATTR_IDN_FBO_PROGRESS_STATE, attr_val))
+		return -EINVAL;
+
+	FBO_DEBUG(fbo, "bFBOProgressState: %u", *attr_val);
+
+	return 0;
+}
+
+static int ufsfbo_execute_analysis(struct ufsfbo_dev *fbo)
+{
+	int ret;
+
+	ret = ufsfbo_issue_write_buffer(fbo);
+	if (ret)
+		return ret;
+
+	if (ufsfbo_write_attr(fbo, QUERY_ATTR_IDN_FBO_CONTROL, FBO_OP_ANALYZE))
+		return -EINVAL;
+
+	return 0;
+}
+
+static void ufsfbo_block_enter_suspend(struct ufsfbo_dev *fbo)
+{
+	struct ufs_hba *hba = fbo->ufsf->hba;
+	struct device *dev = &hba->sdev_ufs_device->sdev_gendev;
+	unsigned long flags;
+
+	ufshcd_rpm_get_sync(hba);
+	ufshcd_hold(hba, false);
+
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	FBO_DEBUG(fbo,
+		  "dev->power.usage_count %d hba->clk_gating.active_reqs %d",
+		  atomic_read(&dev->power.usage_count),
+		  hba->clk_gating.active_reqs);
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+}
+
+/*
+ * Lock status: fbo trigger_lock was held when called.
+ */
+static void ufsfbo_auto_hibern8_enable(struct ufsfbo_dev *fbo,
+				       unsigned int val)
+{
+	struct ufs_hba *hba = fbo->ufsf->hba;
+	unsigned long flags;
+	u32 reg;
+
+	val = !!val;
+
+	/* Update auto hibern8 timer value if supported */
+	if (!ufshcd_is_auto_hibern8_supported(hba))
+		return;
+
+	ufshcd_rpm_get_sync(hba);
+	ufshcd_hold(hba, false);
+	down_write(&hba->clk_scaling_lock);
+	ufsf_scsi_block_requests(hba);
+	/* wait for all the outstanding requests to finish */
+	ufsf_wait_for_doorbell_clr(hba, U64_MAX);
+	spin_lock_irqsave(hba->host->host_lock, flags);
+
+	reg = ufshcd_readl(hba, REG_AUTO_HIBERNATE_IDLE_TIMER);
+	INFO_MSG("ahit-reg 0x%X", reg);
+
+	if (val ^ (reg != 0)) {
+		if (val) {
+			hba->ahit = fbo->ahit;
+		} else {
+			/*
+			 * Store current ahit value.
+			 * We don't know who set the ahit value to different
+			 * from the initial value
+			 */
+			fbo->ahit = reg;
+			hba->ahit = 0;
+		}
+
+		ufshcd_writel(hba, hba->ahit, REG_AUTO_HIBERNATE_IDLE_TIMER);
+
+		/* Make sure the timer gets applied before further operations */
+		mb();
+
+		INFO_MSG("[Before] is_auto_enabled %d", fbo->is_auto_enabled);
+		fbo->is_auto_enabled = val;
+
+		reg = ufshcd_readl(hba, REG_AUTO_HIBERNATE_IDLE_TIMER);
+		INFO_MSG("[After] is_auto_enabled %d ahit-reg 0x%X",
+			 fbo->is_auto_enabled, reg);
+	} else {
+		INFO_MSG("is_auto_enabled %d. so it does not changed",
+			 fbo->is_auto_enabled);
+	}
+
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+	ufsf_scsi_unblock_requests(hba);
+	up_write(&hba->clk_scaling_lock);
+	ufshcd_release(hba);
+	ufsfbo_rpm_put_noidle(hba);
+}
+
+static void ufsfbo_allow_enter_suspend(struct ufsfbo_dev *fbo)
+{
+	struct ufs_hba *hba = fbo->ufsf->hba;
+	struct device *dev = &hba->sdev_ufs_device->sdev_gendev;
+	unsigned long flags;
+
+	ufshcd_release(hba);
+	ufsfbo_rpm_put_noidle(hba);
+
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	FBO_DEBUG(fbo,
+		  "dev->power.usage_count %d hba->clk_gating.active_reqs %d",
+		  atomic_read(&dev->power.usage_count),
+		  hba->clk_gating.active_reqs);
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+}
+
+static inline void ufsfbo_issue_disable(struct ufsfbo_dev *fbo)
+{
+	ufsfbo_write_attr(fbo, QUERY_ATTR_IDN_FBO_CONTROL, FBO_OP_DISABLE);
+}
+
+/*
+ * Lock status: fbo trigger_lock was held when called.
+ */
+static int ufsfbo_trigger_off(struct ufsfbo_dev *fbo, bool init_control)
+	__must_hold(&fbo->trigger_lock)
+{
+	int ret;
+
+	if (!fbo->fbo_trigger)
+		return 0;
+
+	ret = ufsfbo_hold_runtime_pm(fbo);
+	if (ret)
+		return ret;
+
+	fbo->fbo_trigger = false;
+	FBO_DEBUG(fbo, "fbo_trigger 1 -> 0");
+
+	if (init_control)
+		ufsfbo_issue_disable(fbo);
+
+	ufsfbo_auto_hibern8_enable(fbo, 1);
+
+	ufsfbo_allow_enter_suspend(fbo);
+
+	ufsfbo_release_runtime_pm(fbo);
+
+	return 0;
+}
+
+static void ufsfbo_print_read_buffer_result(struct ufsfbo_dev *fbo)
+{
+	int total_entry, entry_cnt, entry_size;
+	struct ufsfbo_rb_body *rb_body;
+	struct ufsfbo_rb_entry *rb_entry;
+	const char *rp = fbo->read_buffer.buf;
+	__u8 cal_all_ranges;
+
+	rp += sizeof(struct ufsfbo_buffer_header);
+
+	rb_body = (struct ufsfbo_rb_body *)rp;
+	cal_all_ranges = rb_body->cal_all_ranges;
+	total_entry = rb_body->num_buffer_entries;
+
+	if (cal_all_ranges)
+		INFO_MSG("CAR %u, All Ranges Regression Level %u",
+			 cal_all_ranges, rb_body->all_reg_level);
+
+	rp += sizeof(struct ufsfbo_rb_body);
+
+	entry_size = sizeof(struct ufsfbo_rb_entry);
+	for (entry_cnt = 0; entry_cnt < total_entry; entry_cnt++, rp += entry_size) {
+		rb_entry = (struct ufsfbo_rb_entry *)rp;
+		INFO_MSG("CAR %u, entry_cnt %d Regression Level %u",
+			 cal_all_ranges, entry_cnt + 1, rb_entry->reg_level);
+	}
+}
+
+static void ufsfbo_parsing_read_buffer_data(struct ufsfbo_dev *fbo,
+					    char *buf)
+{
+	int total_entry, entry_cnt, entry_size;
+	struct ufsfbo_rb_body *rb_body;
+	struct ufsfbo_rb_entry *rb_entry;
+	const char *rp = fbo->read_buffer.buf;
+	__u8 cal_all_ranges;
+	int count = 0;
+
+	rp += sizeof(struct ufsfbo_buffer_header);
+
+	rb_body = (struct ufsfbo_rb_body *)rp;
+	cal_all_ranges = rb_body->cal_all_ranges;
+	total_entry = rb_body->num_buffer_entries;
+
+	if (cal_all_ranges)
+		count += snprintf(buf + count, 32,
+				  "All Ranges Regression Level %2u\n",
+				  rb_body->all_reg_level);
+
+	rp += sizeof(struct ufsfbo_rb_body);
+
+	count += snprintf(buf + count, 7, "CAR %1u\n", cal_all_ranges);
+
+	entry_size = sizeof(struct ufsfbo_rb_entry);
+	for (entry_cnt = 0; entry_cnt < total_entry; entry_cnt++, rp += entry_size) {
+		rb_entry = (struct ufsfbo_rb_entry *)rp;
+		count += snprintf(buf + count, 14, "N %3d lvl %2u\n",
+				  entry_cnt + 1, rb_entry->reg_level);
+	}
+}
+
+static void ufsfbo_trigger_fbo_work_fn(struct work_struct *dwork)
+{
+	bool init_control = true;
+	struct ufsfbo_dev *fbo;
+	u32 attr_val;
+	int ret;
+
+	fbo = container_of(dwork, struct ufsfbo_dev, fbo_trigger_work.work);
+
+	if (ufsfbo_is_not_present(fbo))
+		return;
+
+	FBO_DEBUG(fbo, "start FBO worker");
+
+	mutex_lock(&fbo->trigger_lock);
+	ret = ufsfbo_check_progress_state(fbo, &attr_val);
+	if (ret) {
+		FBO_DEBUG(fbo, "check state err (%d), so trigger off", ret);
+		goto finish_work;
+	}
+
+	switch (attr_val) {
+	case FBO_OP_STATE_IDLE:
+		ret = ufsfbo_execute_analysis(fbo);
+		if (!ret)
+			goto resched;
+
+		FBO_DEBUG(fbo, "execute analysis err (%d), so trigger off", ret);
+		break;
+
+	case FBO_OP_STATE_ON_GOING:
+		FBO_DEBUG(fbo, "on going operation, so re-sched (%u ms)",
+			  fbo->fbo_trigger_delay);
+		goto resched;
+
+	case FBO_OP_STATE_COMPL_ANALYSIS:
+		if (fbo->analysis_only) {
+			init_control = false;
+			FBO_DEBUG(fbo, "Complete analysis, so issue read buffer via sysfs");
+			break;
+		}
+
+		ret = ufsfbo_issue_read_buffer(fbo);
+		if (ret) {
+			FBO_DEBUG(fbo, "issue read buffer err (%d), so trigger off", ret);
+			break;
+		}
+		ufsfbo_print_read_buffer_result(fbo);
+
+		ret = ufsfbo_write_attr(fbo, QUERY_ATTR_IDN_FBO_CONTROL,
+					FBO_OP_EXECUTE);
+		if (!ret)
+			goto resched;
+
+		FBO_DEBUG(fbo, "write attr err (%d), so trigger off", ret);
+		break;
+
+	case FBO_OP_STATE_COMPL_OPTIMIZATION:
+		FBO_DEBUG(fbo, "complete optimization");
+		break;
+
+	case FBO_OP_STATE_ERROR:
+		FBO_DEBUG(fbo, "General err (%d), so trigger off", ret);
+		break;
+	default:
+		FBO_DEBUG(fbo, "invalid attr val (%d), so trigger off", attr_val);
+	}
+finish_work:
+	ufsfbo_trigger_off(fbo, init_control);
+
+	mutex_unlock(&fbo->trigger_lock);
+
+	FBO_DEBUG(fbo, "end FBO worker");
+	return;
+
+resched:
+	mutex_unlock(&fbo->trigger_lock);
+
+	schedule_delayed_work(&fbo->fbo_trigger_work,
+			      msecs_to_jiffies(fbo->fbo_trigger_delay));
+
+	FBO_DEBUG(fbo, "re-schedule FBO worker");
+}
+
+static void ufsfbo_restore_attr(struct ufsf_feature *ufsf)
+{
+	struct ufsfbo_dev *fbo = ufsf->fbo_dev;
+	int err;
+
+	err = ufsfbo_write_attr(fbo, QUERY_ATTR_IDN_FBO_EXECUTE_THRESHOLD,
+				fbo->execute_threshold);
+	if (err)
+		ERR_MSG("Write attr failed");
+}
+
+static void ufsfbo_init_threshold_attr(struct ufsfbo_dev *fbo)
+{
+	u8 idn = QUERY_ATTR_IDN_FBO_EXECUTE_THRESHOLD;
+	struct ufs_hba *hba = fbo->ufsf->hba;
+	struct device *dev = hba->dev;
+	u32 val;
+	int ret;
+
+	/* Set default excution threshold value */
+	fbo->execute_threshold = FBO_EXECUTE_THRESHOLD_DEFAULT;
+	val = (u32)fbo->execute_threshold;
+
+	pm_runtime_get_sync(dev);
+	ret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_WRITE_ATTR,
+				      idn, 0, 0, &val);
+	pm_runtime_put_noidle(dev);
+
+	if (ret)
+		ERR_MSG("write attr [0x%.2X] failed. (%d)", idn, ret);
+	else
+		FBO_DEBUG(fbo, "fbo_attr write [0x%.2X] %u (0x%X)", idn, val,
+			  val);
+}
+
+void ufsfbo_init(struct ufsf_feature *ufsf)
+{
+	struct ufsfbo_dev *fbo = ufsf->fbo_dev;
+	int ret;
+
+
+	INFO_MSG("FBO_INIT_START");
+
+	if (!fbo) {
+		INFO_MSG("samsung fbo is not found. it may not support samsung fbo feature. check it");
+		ufsfbo_set_state(ufsf, FBO_FAILED);
+		return;
+	}
+
+	fbo->fbo_trigger = false;
+	fbo->fbo_trigger_delay = FBO_TRIGGER_WORKER_DELAY_MS_DEFAULT;
+	INIT_DELAYED_WORK(&fbo->fbo_trigger_work, ufsfbo_trigger_fbo_work_fn);
+
+	ufsfbo_init_threshold_attr(fbo);
+
+#if defined(CONFIG_UFSFBO_POC)
+	fbo->get_pm = false;
+#endif
+	fbo->fbo_debug = false;
+
+	/* If HCI supports auto hibern8, UFS Driver use it default */
+	if (ufshcd_is_auto_hibern8_supported(ufsf->hba))
+		fbo->is_auto_enabled = true;
+	else
+		fbo->is_auto_enabled = false;
+
+	/* Save default Auto-Hibernate Idle Timer register value */
+	fbo->ahit = ufsf->hba->ahit;
+
+	mutex_init(&fbo->trigger_lock);
+
+	ret = ufsfbo_create_sysfs(fbo);
+	if (ret) {
+		ERR_MSG("sysfs init failed. So FBO driver disabled");
+		kfree(fbo);
+		ufsfbo_set_state(ufsf, FBO_FAILED);
+		return;
+	}
+
+	INFO_MSG("UFS FBO create sysfs finished");
+
+	ufsfbo_set_state(ufsf, FBO_PRESENT);
+}
+
+static int ufsfbo_check_lba_range_info_buf(struct ufsfbo_dev *fbo,
+					   unsigned char *buf, __u16 size)
+{
+	struct ufsfbo_buffer_header *buffer_header;
+	struct ufsfbo_wb_body *buffer_body;
+	struct ufsfbo_wb_entry *entry, *comp_entry;
+	const char *p = buf;
+	int entry_cnt, total_entry, comp_cnt, entry_size, header_size, body_size;
+	u32 lba, comp_lba, len, comp_len;
+
+	INFO_MSG("buf size %d", size);
+
+	buffer_header = (struct ufsfbo_buffer_header *)p;
+	if (buffer_header->fbo_type != 0x0)
+		return -EINVAL;
+
+	header_size = sizeof(struct ufsfbo_buffer_header);
+	p += header_size;
+
+	buffer_body = (struct ufsfbo_wb_body *)p;
+	total_entry = buffer_body->num_buffer_entries;
+	if (!total_entry || total_entry > fbo->max_lba_range_count ||
+	    total_entry > FBO_MAX_RANGE_COUNT) {
+		ERR_MSG("total_entry (%d). so check it", total_entry);
+		return -EINVAL;
+	}
+
+	body_size = sizeof(struct ufsfbo_wb_body);
+	p += body_size;
+
+	entry_size = sizeof(struct ufsfbo_wb_entry);
+	for (entry_cnt = 0; entry_cnt < total_entry; entry_cnt++, p += entry_size) {
+		const char *comp_p;
+		__be32 length;
+
+		entry = (struct ufsfbo_wb_entry *)p;
+		length = (__be32)entry->length;
+		lba = get_unaligned_be32(&entry->start_lba);
+		len = get_unaligned_be24(&length) >> BYTE_TO_BLK_SHIFT;
+
+		if (!lba || !len) {
+			ERR_MSG("entry[%d] info is not valid", entry_cnt);
+			return -EINVAL;
+		}
+
+		if (len > fbo->max_lba_range_size || len < fbo->min_lba_range_size) {
+			ERR_MSG("entry[%d] len (%u) is wrong. max %u, min %u",
+				entry_cnt, len, fbo->max_lba_range_size,
+				fbo->min_lba_range_size);
+			return -EINVAL;
+		}
+
+		INFO_MSG("entry_cnt[%d] lba %u len %u", entry_cnt, lba, len);
+
+		comp_p = buf + header_size + body_size;
+		for (comp_cnt = 0; comp_cnt < entry_cnt;
+		     comp_cnt++, comp_p += entry_size) {
+			__be32 comp_length;
+
+			comp_entry = (struct ufsfbo_wb_entry *)comp_p;
+			comp_length = (__be32)comp_entry->length;
+			comp_lba = get_unaligned_be32(&comp_entry->start_lba);
+			comp_len = get_unaligned_be24(&comp_length) >> BYTE_TO_BLK_SHIFT;
+
+			if (lba + len - 1 >= comp_lba &&
+			    lba <= comp_lba + comp_len - 1) {
+				ERR_MSG("Overlapped: lba %u len %u comp_lba %u comp_len %u",
+					lba, len, comp_lba, comp_len);
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Lock status: fbo trigger_lock was held when called.
+ */
+static int ufsfbo_trigger_on(struct ufsfbo_dev *fbo)
+	__must_hold(&fbo->trigger_lock)
+{
+	int ret;
+
+	ret = ufsfbo_hold_runtime_pm(fbo);
+	if (ret)
+		return ret;
+
+	if (fbo->fbo_trigger) {
+		schedule_delayed_work(&fbo->fbo_trigger_work, 0);
+		ufsfbo_release_runtime_pm(fbo);
+		return 0;
+	}
+
+	fbo->fbo_trigger = true;
+	FBO_DEBUG(fbo, "trigger 0 -> 1");
+
+	ufsfbo_block_enter_suspend(fbo);
+
+	ufsfbo_auto_hibern8_enable(fbo, 0);
+
+	schedule_delayed_work(&fbo->fbo_trigger_work, 0);
+
+	ufsfbo_release_runtime_pm(fbo);
+
+	return 0;
+}
+
+int ufsfbo_send_file_info(struct ufsfbo_dev *fbo, int lun, unsigned char *buf,
+			  __u16 size, __u8 idn, int opcode)
+{
+	int ret;
+
+	ret = ufsfbo_check_lba_range_info_buf(fbo, buf, size);
+	if (ret)
+		return ret;
+
+	mutex_lock(&fbo->trigger_lock);
+	ufsfbo_init_buffers(fbo, lun, buf, size);
+
+	ufsfbo_issue_disable(fbo);
+
+	/*
+	 * For analysis only, the opcode is set to UPIU_QUERY_OPCODE_READ_ATTR
+	 * via ioctl
+	 */
+	fbo->analysis_only = (opcode == UPIU_QUERY_OPCODE_READ_ATTR);
+
+	ret = ufsfbo_trigger_on(fbo);
+	if (ret)
+		INFO_MSG("Trigger on is fail (%d)", ret);
+	mutex_unlock(&fbo->trigger_lock);
+
+	return ret;
+}
+
+void ufsfbo_reset_host(struct ufsf_feature *ufsf)
+{
+	struct ufsfbo_dev *fbo = ufsf->fbo_dev;
+
+	if (!fbo)
+		return;
+
+	ufsfbo_set_state(ufsf, FBO_RESET);
+	cancel_delayed_work_sync(&fbo->fbo_trigger_work);
+}
+
+void ufsfbo_reset(struct ufsf_feature *ufsf)
+{
+	struct ufsfbo_dev *fbo = ufsf->fbo_dev;
+
+	if (!fbo)
+		return;
+
+	ufsfbo_set_state(ufsf, FBO_PRESENT);
+
+	/*
+	 * fbo_trigger will be checked under trigger_lock in worker.
+	 */
+	if (fbo->fbo_trigger)
+		schedule_delayed_work(&fbo->fbo_trigger_work, 0);
+
+	ufsfbo_restore_attr(ufsf);
+
+	INFO_MSG("reset completed.");
+}
+
+static inline void ufsfbo_remove_sysfs(struct ufsfbo_dev *fbo)
+{
+	int ret;
+
+	ret = kobject_uevent(&fbo->kobj, KOBJ_REMOVE);
+	INFO_MSG("kobject removed (%d)", ret);
+	kobject_del(&fbo->kobj);
+}
+
+void ufsfbo_remove(struct ufsf_feature *ufsf)
+{
+	struct ufsfbo_dev *fbo = ufsf->fbo_dev;
+	int ret;
+
+	if (!fbo)
+		return;
+
+	INFO_MSG("start FBO release");
+
+	mutex_lock(&fbo->trigger_lock);
+	ret = ufsfbo_trigger_off(fbo, true);
+	if (unlikely(ret))
+		ERR_MSG("trigger off fail ret (%d)", ret);
+	ufsfbo_set_state(ufsf, FBO_FAILED);
+	mutex_unlock(&fbo->trigger_lock);
+
+	mutex_lock(&fbo->sysfs_lock);
+	ufsfbo_remove_sysfs(fbo);
+	mutex_unlock(&fbo->sysfs_lock);
+
+	cancel_delayed_work_sync(&fbo->fbo_trigger_work);
+
+	kfree(fbo);
+
+	INFO_MSG("end FBO release");
+}
+
+void ufsfbo_suspend(struct ufsf_feature *ufsf)
+{
+	struct ufsfbo_dev *fbo = ufsf->fbo_dev;
+
+	if (!fbo)
+		return;
+
+	if (unlikely(fbo->fbo_trigger))
+		ERR_MSG("fbo_trigger was set to block the suspend.");
+
+	ufsfbo_set_state(ufsf, FBO_SUSPEND);
+
+	cancel_delayed_work_sync(&fbo->fbo_trigger_work);
+}
+
+void ufsfbo_resume(struct ufsf_feature *ufsf, bool is_link_off)
+{
+	struct ufsfbo_dev *fbo = ufsf->fbo_dev;
+
+	if (!fbo)
+		return;
+
+	if (is_link_off)
+		ufsfbo_restore_attr(ufsf);
+
+	ufsfbo_set_state(ufsf, FBO_PRESENT);
+
+	/*
+	 * If trigger off fails due to System PM, call ufsfbo_trigger_off() to
+	 * release the blocked suspend.
+	 */
+	mutex_lock(&fbo->trigger_lock);
+	if (unlikely(fbo->fbo_trigger))
+		ufsfbo_trigger_off(fbo, true);
+	mutex_unlock(&fbo->trigger_lock);
+}
+
+/* sysfs function */
+static ssize_t ufsfbo_sysfs_show_version(struct ufsfbo_dev *fbo, char *buf)
+{
+	INFO_MSG("FBO version (%.4X) D/D version (%.6X%s)",
+		 UFSFBO_VER, UFSFBO_DD_VER, UFSFBO_DD_VER_POST);
+
+	return sysfs_emit(buf, "FBO version (%.4X) D/D version (%.6X%s)\n",
+			  UFSFBO_VER, UFSFBO_DD_VER, UFSFBO_DD_VER_POST);
+}
+
+static ssize_t ufsfbo_sysfs_show_max_lba_range_size(struct ufsfbo_dev *fbo,
+						    char *buf)
+{
+	INFO_MSG("max_lba_range_size %d", fbo->max_lba_range_size);
+
+	return sysfs_emit(buf, "%d\n", fbo->max_lba_range_size);
+}
+
+static ssize_t ufsfbo_sysfs_show_min_lba_range_size(struct ufsfbo_dev *fbo,
+						    char *buf)
+{
+	INFO_MSG("min_lba_range_size %d", fbo->min_lba_range_size);
+
+	return sysfs_emit(buf, "%d\n", fbo->min_lba_range_size);
+}
+
+static ssize_t ufsfbo_sysfs_show_max_lba_range_count(struct ufsfbo_dev *fbo,
+						     char *buf)
+{
+	INFO_MSG("max_lba_range_count %d", fbo->max_lba_range_count);
+
+	return sysfs_emit(buf, "%d\n", fbo->max_lba_range_count);
+}
+
+static ssize_t ufsfbo_sysfs_show_lba_range_alignment(struct ufsfbo_dev *fbo,
+						 char *buf)
+{
+	INFO_MSG("lba_range_alignment %d", fbo->lba_range_alignment);
+
+	return sysfs_emit(buf, "%d\n", fbo->lba_range_alignment);
+}
+
+static ssize_t ufsfbo_sysfs_show_progress_state(struct ufsfbo_dev *fbo,
+						char *buf)
+{
+	u32 attr_val;
+
+	mutex_lock(&fbo->trigger_lock);
+	if (ufsfbo_check_progress_state(fbo, &attr_val)) {
+		mutex_unlock(&fbo->trigger_lock);
+		return -EINVAL;
+	}
+
+#if defined(CONFIG_UFSFBO_POC)
+	/*
+	 * Paired with ufsfbo_sysfs_store_optimize()
+	 */
+	if (fbo->get_pm &&
+	    (attr_val == FBO_OP_STATE_COMPL_OPTIMIZATION ||
+	     attr_val == FBO_OP_STATE_ERROR)) {
+		ufsfbo_auto_hibern8_enable(fbo, 1);
+		ufsfbo_allow_enter_suspend(fbo);
+		fbo->get_pm = false;
+	}
+#endif
+
+	mutex_unlock(&fbo->trigger_lock);
+
+	return sysfs_emit(buf, "%s\n",
+			  attr_val == FBO_OP_STATE_IDLE ? "IDLE" :
+			  attr_val == FBO_OP_STATE_ON_GOING ? "ON_GOING" :
+			  attr_val == FBO_OP_STATE_COMPL_ANALYSIS ? "COMPL_ANALYSIS" :
+			  attr_val == FBO_OP_STATE_COMPL_OPTIMIZATION ? "COMPL_OPTIMIZATION" :
+			  "STATE_ERROR");
+}
+
+static ssize_t ufsfbo_sysfs_show_analyze(struct ufsfbo_dev *fbo, char *buf)
+{
+	u32 attr_val;
+	int ret;
+
+	mutex_lock(&fbo->trigger_lock);
+	if (ufsfbo_check_progress_state(fbo, &attr_val))
+		goto error;
+
+	if (attr_val != FBO_OP_STATE_COMPL_ANALYSIS) {
+		ERR_MSG("State error, check current state (%d)", attr_val);
+		goto error;
+	}
+
+	ret = ufsfbo_issue_read_buffer(fbo);
+	if (ret)
+		goto error;
+
+	ufsfbo_parsing_read_buffer_data(fbo, buf);
+	mutex_unlock(&fbo->trigger_lock);
+
+	return sysfs_emit(buf, "%s\n", buf);
+error:
+	mutex_unlock(&fbo->trigger_lock);
+	return -EINVAL;
+}
+
+static ssize_t ufsfbo_sysfs_show_trigger_interval(struct ufsfbo_dev *fbo,
+						  char *buf)
+{
+	INFO_MSG("fbo_trigger_interval %d", fbo->fbo_trigger_delay);
+
+	return sysfs_emit(buf, "%d\n", fbo->fbo_trigger_delay);
+}
+
+static ssize_t ufsfbo_sysfs_store_trigger_interval(struct ufsfbo_dev *fbo,
+						   const char *buf,
+						   size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val < FBO_TRIGGER_WORKER_DELAY_MS_MIN ||
+	    val > FBO_TRIGGER_WORKER_DELAY_MS_MAX) {
+		INFO_MSG("fbo_trigger_interval (min) %4dms ~ (max) %4dms",
+			 FBO_TRIGGER_WORKER_DELAY_MS_MIN,
+			 FBO_TRIGGER_WORKER_DELAY_MS_MAX);
+		return -EINVAL;
+	}
+
+	fbo->fbo_trigger_delay = val;
+	INFO_MSG("fbo_trigger_interval %d", fbo->fbo_trigger_delay);
+
+	return count;
+}
+
+static ssize_t ufsfbo_sysfs_show_execute_threshold(struct ufsfbo_dev *fbo,
+						   char *buf)
+{
+	INFO_MSG("execute_threshold %u", fbo->execute_threshold);
+
+	return sysfs_emit(buf, "%u\n", fbo->execute_threshold);
+}
+
+static ssize_t ufsfbo_sysfs_store_execute_threshold(struct ufsfbo_dev *fbo,
+						    const char *buf,
+						    size_t count)
+{
+	int ret;
+	u8 val;
+
+	if (kstrtou8(buf, 0, &val))
+		return -EINVAL;
+
+	if (val > FBO_MAX_EXECUTE_THRESHOLD)
+		return -EINVAL;
+
+	ret = ufsfbo_write_attr(fbo, QUERY_ATTR_IDN_FBO_EXECUTE_THRESHOLD, val);
+	if (ret)
+		return -EINVAL;
+
+	fbo->execute_threshold = val;
+
+	INFO_MSG("execute_threshold %u", fbo->execute_threshold);
+
+	return count;
+}
+
+#if defined(CONFIG_UFSFBO_POC)
+static ssize_t ufsfbo_sysfs_store_optimize(struct ufsfbo_dev *fbo,
+					   const char *buf,
+					   size_t count)
+{
+	unsigned int val;
+	u32 attr_val;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != RUN_OPTIMIZATION)
+		return -EINVAL;
+
+	mutex_lock(&fbo->trigger_lock);
+	if (ufsfbo_check_progress_state(fbo, &attr_val))
+		goto error;
+
+	if (attr_val != FBO_OP_STATE_COMPL_ANALYSIS) {
+		ERR_MSG("First, need to run analysis in FBO application");
+		goto error;
+	}
+
+	/*
+	 * It must be released in the ufsfbo_sysfs_show_progress_state()
+	 */
+	if (!fbo->get_pm) {
+		fbo->get_pm = true;
+		ufsfbo_block_enter_suspend(fbo);
+		ufsfbo_auto_hibern8_enable(fbo, 0);
+	}
+
+	if (ufsfbo_write_attr(fbo, QUERY_ATTR_IDN_FBO_CONTROL, FBO_OP_EXECUTE))
+		goto error;
+
+	mutex_unlock(&fbo->trigger_lock);
+
+	INFO_MSG("Success: Run optimization");
+
+	return count;
+error:
+	mutex_unlock(&fbo->trigger_lock);
+	return -EINVAL;
+}
+#endif
+
+static ssize_t ufsfbo_sysfs_show_debug(struct ufsfbo_dev *fbo, char *buf)
+{
+	INFO_MSG("debug %d", fbo->fbo_debug);
+
+	return sysfs_emit(buf, "%d\n", fbo->fbo_debug);
+}
+
+static ssize_t ufsfbo_sysfs_store_debug(struct ufsfbo_dev *fbo, const char *buf,
+					size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	fbo->fbo_debug = val ? true : false;
+
+	INFO_MSG("debug %d", fbo->fbo_debug);
+
+	return count;
+}
+
+/* SYSFS DEFINE */
+#define define_sysfs_ro(_name) __ATTR(_name, 0444,			\
+				      ufsfbo_sysfs_show_##_name, NULL)
+#define define_sysfs_rw(_name) __ATTR(_name, 0644,			\
+				      ufsfbo_sysfs_show_##_name,	\
+				      ufsfbo_sysfs_store_##_name)
+#define define_sysfs_wo(_name) __ATTR(_name, 0220, NULL,		\
+				      ufsfbo_sysfs_store_##_name)
+
+static struct ufsfbo_sysfs_entry ufsfbo_sysfs_entries[] = {
+	define_sysfs_ro(version),
+	define_sysfs_ro(max_lba_range_size),
+	define_sysfs_ro(min_lba_range_size),
+	define_sysfs_ro(max_lba_range_count),
+	define_sysfs_ro(lba_range_alignment),
+	define_sysfs_ro(progress_state),
+	define_sysfs_ro(analyze),
+
+	define_sysfs_rw(trigger_interval),
+	define_sysfs_rw(execute_threshold),
+
+#if defined(CONFIG_UFSFBO_POC)
+	define_sysfs_wo(optimize),
+#endif
+
+	/* debug */
+	define_sysfs_rw(debug),
+	__ATTR_NULL,
+};
+
+static ssize_t ufsfbo_attr_show(struct kobject *kobj, struct attribute *attr,
+				char *page)
+{
+	struct ufsfbo_sysfs_entry *entry;
+	struct ufsfbo_dev *fbo;
+	ssize_t error;
+
+	entry = container_of(attr, struct ufsfbo_sysfs_entry, attr);
+	if (!entry->show)
+		return -EIO;
+
+	fbo = container_of(kobj, struct ufsfbo_dev, kobj);
+	error = ufsfbo_hold_runtime_pm(fbo);
+	if (error)
+		return error;
+
+	mutex_lock(&fbo->sysfs_lock);
+	error = entry->show(fbo, page);
+	mutex_unlock(&fbo->sysfs_lock);
+
+	ufsfbo_release_runtime_pm(fbo);
+	return error;
+}
+
+static ssize_t ufsfbo_attr_store(struct kobject *kobj, struct attribute *attr,
+				 const char *page, size_t length)
+{
+	struct ufsfbo_sysfs_entry *entry;
+	struct ufsfbo_dev *fbo;
+	ssize_t error;
+
+	entry = container_of(attr, struct ufsfbo_sysfs_entry, attr);
+	if (!entry->store)
+		return -EIO;
+
+	fbo = container_of(kobj, struct ufsfbo_dev, kobj);
+	error = ufsfbo_hold_runtime_pm(fbo);
+	if (error)
+		return error;
+
+	mutex_lock(&fbo->sysfs_lock);
+	error = entry->store(fbo, page, length);
+	mutex_unlock(&fbo->sysfs_lock);
+
+	ufsfbo_release_runtime_pm(fbo);
+	return error;
+}
+
+static const struct sysfs_ops ufsfbo_sysfs_ops = {
+	.show = ufsfbo_attr_show,
+	.store = ufsfbo_attr_store,
+};
+
+static struct kobj_type ufsfbo_ktype = {
+	.sysfs_ops = &ufsfbo_sysfs_ops,
+	.release = NULL,
+};
+
+static int ufsfbo_create_sysfs(struct ufsfbo_dev *fbo)
+{
+	struct device *dev = fbo->ufsf->hba->dev;
+	struct ufsfbo_sysfs_entry *entry;
+	int err;
+
+	fbo->sysfs_entries = ufsfbo_sysfs_entries;
+
+	kobject_init(&fbo->kobj, &ufsfbo_ktype);
+	mutex_init(&fbo->sysfs_lock);
+
+	INFO_MSG("ufsfbo creates sysfs ufsfbo %p dev->kobj %p",
+		 &fbo->kobj, &dev->kobj);
+
+	err = kobject_add(&fbo->kobj, kobject_get(&dev->kobj), "ufsfbo");
+	if (!err) {
+		for (entry = fbo->sysfs_entries; entry->attr.name != NULL;
+		     entry++) {
+			INFO_MSG("ufsfbo sysfs attr creates: %s",
+				 entry->attr.name);
+			err = sysfs_create_file(&fbo->kobj, &entry->attr);
+			if (err) {
+				ERR_MSG("create entry(%s) failed",
+					entry->attr.name);
+				goto kobj_del;
+			}
+		}
+		kobject_uevent(&fbo->kobj, KOBJ_ADD);
+	} else {
+		ERR_MSG("kobject_add failed");
+	}
+
+	return err;
+kobj_del:
+	err = kobject_uevent(&fbo->kobj, KOBJ_REMOVE);
+	INFO_MSG("kobject removed (%d)", err);
+	kobject_del(&fbo->kobj);
+	return -EINVAL;
+}
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/scsi/ufs/vendor/ufsfbo.h b/drivers/scsi/ufs/vendor/ufsfbo.h
new file mode 100644
index 000000000000..cc088a69fef4
--- /dev/null
+++ b/drivers/scsi/ufs/vendor/ufsfbo.h
@@ -0,0 +1,201 @@
+/*
+ * Universal Flash Storage File Base Optimization
+ *
+ * Copyright (C) 2022 Samsung Electronics Co., Ltd.
+ *
+ * Author:
+ *	Keoseong Park <keosung.park@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ *
+ * The Linux Foundation chooses to take subject only to the GPLv2
+ * license terms, and distributes only under these terms.
+ */
+
+#ifndef _UFSFBO_H_
+#define _UFSFBO_H_
+
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/blktrace_api.h>
+#include <linux/blkdev.h>
+#include <linux/bitfield.h>
+#include <scsi/scsi_cmnd.h>
+
+#include "../../../block/blk.h"
+
+#define UFSFBO_VER				0x0100
+#define UFSFBO_DD_VER				0x010100
+#define UFSFBO_DD_VER_POST			""
+
+#define UFS_FEATURE_SUPPORT_FBO_BIT		BIT(17)
+
+#define FBO_TRIGGER_WORKER_DELAY_MS_DEFAULT	500
+#define FBO_TRIGGER_WORKER_DELAY_MS_MIN		100
+#define FBO_TRIGGER_WORKER_DELAY_MS_MAX		10000
+
+#define FBO_EXECUTE_THRESHOLD_DEFAULT		0x02
+
+#define FBO_REQ_TIMEOUT				(10 * HZ)
+#define FBO_MAX_RANGE_COUNT			(1 << 8)
+
+#define FBO_MAX_EXECUTE_THRESHOLD		0xA
+
+#define WRITE_BUFFER_DATA_MODE			0x2
+#define WRITE_BUFFER_ID				0x1
+#define READ_BUFFER_DATA_MODE			0x2
+#define READ_BUFFER_ID				0x2
+
+#define BYTE_TO_BLK_SHIFT			12
+
+#define RUN_OPTIMIZATION			1
+
+#define FBO_DEBUG(fbo, msg, args...)					\
+	do { if (fbo->fbo_debug)					\
+		pr_err("%40s:%3d [%01d%02d%02d] " msg "\n",		\
+		       __func__, __LINE__,				\
+		       fbo->fbo_trigger,				\
+		       atomic_read(&fbo->ufsf->hba->dev->power.usage_count),\
+		       fbo->ufsf->hba->clk_gating.active_reqs, ##args);	\
+	} while (0)
+
+enum UFSFBO_STATE {
+	FBO_NEED_INIT = 0,
+	FBO_PRESENT = 1,
+	FBO_SUSPEND = 2,
+	FBO_FAILED = -2,
+	FBO_RESET = -3,
+};
+
+enum UFSFBO_OP {
+	FBO_OP_DISABLE	= 0,
+	FBO_OP_ANALYZE	= 1,
+	FBO_OP_EXECUTE	= 2,
+	FBO_OP_MAX
+};
+
+enum UFSFBO_OP_STATE {
+	FBO_OP_STATE_IDLE		= 0x00,
+	FBO_OP_STATE_ON_GOING		= 0x01,
+	FBO_OP_STATE_COMPL_ANALYSIS	= 0x02,
+	FBO_OP_STATE_COMPL_OPTIMIZATION	= 0x03,
+	FBO_OP_STATE_ERROR		= 0xFF,
+};
+
+struct ufsfbo_wb_entry {
+	__be32 start_lba;
+	__be32 length:24;
+	__be32 reserved:8;
+} __packed;
+
+struct ufsfbo_wb_body {
+	__u8 version;
+	__u8 num_buffer_entries;
+	__u8 cal_all_ranges;
+	__u8 reserved[5];
+};
+
+struct ufsfbo_rb_entry {
+	__be32 start_lba;
+	__be32 length:24;
+	__be32 reg_level:8;
+} __packed;
+
+struct ufsfbo_rb_body {
+	__u8 version;
+	__u8 num_buffer_entries;
+	__u8 cal_all_ranges;
+	__u8 all_reg_level;
+	__u8 reserved[4];
+};
+
+struct ufsfbo_buffer_header {
+	__u8 fbo_type;
+	__u8 reserved[3];
+};
+
+struct ufsfbo_req {
+	int lun;
+	u8 buf[PAGE_SIZE];
+	size_t buf_size;
+};
+
+struct ufsfbo_dev {
+	struct ufsf_feature *ufsf;
+
+	unsigned int fbo_trigger;
+	struct delayed_work fbo_trigger_work;
+	unsigned int fbo_trigger_delay;
+
+	u32 ahit;			/* to restore ahit value */
+	bool is_auto_enabled;
+
+	bool analysis_only;
+
+	u32 rec_lba_range_size;
+	u32 max_lba_range_size;
+	u32 min_lba_range_size;
+	u8 max_lba_range_count;
+	u16 lba_range_alignment;
+
+	u8 execute_threshold;
+
+	struct ufsfbo_req write_buffer;
+	struct ufsfbo_req read_buffer;
+
+#if defined(CONFIG_UFSFBO_POC)
+	bool get_pm;
+#endif
+
+	struct mutex trigger_lock;
+
+	/* for sysfs */
+	struct kobject kobj;
+	struct mutex sysfs_lock;
+	struct ufsfbo_sysfs_entry *sysfs_entries;
+
+	/* for debug */
+	bool fbo_debug;
+};
+
+struct ufsfbo_sysfs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct ufsfbo_dev *fbo, char *buf);
+	ssize_t (*store)(struct ufsfbo_dev *fbo, const char *buf, size_t count);
+};
+
+void ufsfbo_init(struct ufsf_feature *ufsf);
+void ufsfbo_reset(struct ufsf_feature *ufsf);
+void ufsfbo_reset_host(struct ufsf_feature *ufsf);
+void ufsfbo_remove(struct ufsf_feature *ufsf);
+void ufsfbo_suspend(struct ufsf_feature *ufsf);
+void ufsfbo_resume(struct ufsf_feature *ufsf, bool is_link_off);
+int ufsfbo_send_file_info(struct ufsfbo_dev *fbo, int lun, unsigned char *buf,
+			  __u16 size, __u8 idn, int opcode);
+int ufsfbo_get_state(struct ufsf_feature *ufsf);
+void ufsfbo_set_state(struct ufsf_feature *ufsf, int state);
+void ufsfbo_get_dev_info(struct ufsf_feature *ufsf);
+void ufsfbo_read_fbo_desc(struct ufsf_feature *ufsf);
+#endif /* End of Header */
diff --git a/drivers/scsi/ufs/vendor/ufsfeature.c b/drivers/scsi/ufs/vendor/ufsfeature.c
index 1b287fe01236..b8d9a38a1e3f 100644
--- a/drivers/scsi/ufs/vendor/ufsfeature.c
+++ b/drivers/scsi/ufs/vendor/ufsfeature.c
@@ -39,6 +39,10 @@
 #include "ufshcd.h"
 #include "ufs-qcom.h"
 
+inline int is_vendor_device(struct ufs_hba *hba, int id)
+{
+	return (hba != NULL && hba->dev_info.wmanufacturerid == id);
+}
 static int ufsf_read_desc(struct ufs_hba *hba, u8 desc_id, u8 desc_index,
 			  u8 *desc_buf, u32 size)
 {
@@ -61,8 +65,12 @@ static int ufsf_read_dev_desc(struct ufsf_feature *ufsf)
 {
 	u8 desc_buf[UFSF_QUERY_DESC_DEVICE_MAX_SIZE];
 	int ret;
+	u8 idn = 0;
+
+	if (is_vendor_device(ufsf->hba, UFS_VENDOR_SAMSUNG))
+		idn = UFSF_QUERY_DESC_IDN_DEVICE;
 
-	ret = ufsf_read_desc(ufsf->hba, UFSF_QUERY_DESC_IDN_DEVICE, 0,
+	ret = ufsf_read_desc(ufsf->hba, idn, 0,
 			     desc_buf, UFSF_QUERY_DESC_DEVICE_MAX_SIZE);
 	if (ret)
 		return ret;
@@ -90,6 +98,10 @@ static int ufsf_read_dev_desc(struct ufsf_feature *ufsf)
 #if defined(CONFIG_UFSSID)
 	ufssid_get_dev_info(ufsf, desc_buf);
 #endif
+
+#if defined(CONFIG_UFSFBO)
+	ufsfbo_get_dev_info(ufsf);
+#endif
 	return 0;
 }
 
@@ -98,7 +110,11 @@ static int ufsf_read_geo_desc(struct ufsf_feature *ufsf)
 	u8 geo_buf[UFSF_QUERY_DESC_GEOMETRY_MAX_SIZE];
 	int ret;
 
-	ret = ufsf_read_desc(ufsf->hba, UFSF_QUERY_DESC_IDN_GEOMETRY, 0,
+	u8 idn = QUERY_DESC_IDN_GEOMETRY;
+
+	if (is_vendor_device(ufsf->hba, UFS_VENDOR_SAMSUNG))
+		idn = UFSF_QUERY_DESC_IDN_GEOMETRY;
+	ret = ufsf_read_desc(ufsf->hba, idn, 0,
 			     geo_buf, UFSF_QUERY_DESC_GEOMETRY_MAX_SIZE);
 	if (ret)
 		return ret;
@@ -118,6 +134,9 @@ void ufsf_device_check(struct ufs_hba *hba)
 	if (ufsf_read_dev_desc(ufsf))
 		return;
 
+#if defined(CONFIG_UFSFBO)
+	ufsfbo_read_fbo_desc(ufsf);
+#endif
 	ufsf_read_geo_desc(ufsf);
 }
 
@@ -227,6 +246,12 @@ int ufsf_query_ioctl(struct ufsf_feature *ufsf, int lun, void __user *buffer,
 		buf_len = ioctl_data->buf_size;
 		break;
 #endif
+
+#if defined(CONFIG_UFSFBO)
+	case QUERY_ATTR_IDN_FBO_CONTROL:
+		buf_len = ioctl_data->buf_size;
+		break;
+#endif
 	default:
 		buf_len = QUERY_DESC_MAX_SIZE;
 		break;
@@ -306,6 +331,23 @@ int ufsf_query_ioctl(struct ufsf_feature *ufsf, int lun, void __user *buffer,
 
 			goto out_release_mem;
 #endif
+
+#if defined(CONFIG_UFSFBO)
+		case QUERY_ATTR_IDN_FBO_CONTROL:
+			err = copy_from_user(kernel_buf, buffer +
+					sizeof(struct ufs_ioctl_query_data),
+					ioctl_data->buf_size);
+			if (err)
+				goto out_release_mem;
+
+			err = ufsfbo_send_file_info(ufsf->fbo_dev, lun,
+						    kernel_buf, buf_len,
+						    ioctl_data->idn, opcode);
+			if (err)
+				ERR_MSG("FBO LBA Trigger failed. (%d)", err);
+
+			goto out_release_mem;
+#endif
 		default:
 			break;
 		}
@@ -330,6 +372,22 @@ int ufsf_query_ioctl(struct ufsf_feature *ufsf, int lun, void __user *buffer,
 			}
 
 			goto copy_buffer;
+#endif
+#if defined(CONFIG_UFSFBO)
+		case QUERY_ATTR_IDN_FBO_CONTROL:
+			err = copy_from_user(kernel_buf, buffer +
+					sizeof(struct ufs_ioctl_query_data),
+					ioctl_data->buf_size);
+			if (err)
+				goto out_release_mem;
+
+			err = ufsfbo_send_file_info(ufsf->fbo_dev, lun,
+						    kernel_buf, buf_len,
+						    ioctl_data->idn, opcode);
+			if (err)
+				ERR_MSG("FBO LBA Trigger failed. (%d)", err);
+
+			goto out_release_mem;
 #endif
 		default:
 			break;
@@ -507,6 +565,13 @@ inline void ufsf_reset_host(struct ufsf_feature *ufsf)
 	if (ufshid_get_state(ufsf) == HID_PRESENT)
 		ufshid_reset_host(ufsf);
 #endif
+
+#if defined(CONFIG_UFSFBO)
+	INFO_MSG("run reset_host.. fbo_state(%d) -> FBO_RESET",
+		 ufsfbo_get_state(ufsf));
+	if (ufsfbo_get_state(ufsf) == FBO_PRESENT)
+		ufsfbo_reset_host(ufsf);
+#endif
 	schedule_work(&ufsf->reset_wait_work);
 }
 
@@ -520,7 +585,10 @@ inline void ufsf_init(struct ufsf_feature *ufsf)
 	if (ufsf->sid_dev)
 		ufssid_init(ufsf);
 #endif
-
+#if defined(CONFIG_UFSFBO)
+	if (ufsfbo_get_state(ufsf) == FBO_NEED_INIT)
+		ufsfbo_init(ufsf);
+#endif
 	ufsf->check_init = true;
 }
 
@@ -530,6 +598,10 @@ inline void ufsf_reset(struct ufsf_feature *ufsf)
 	if (ufshid_get_state(ufsf) == HID_RESET)
 		ufshid_reset(ufsf);
 #endif
+#if defined(CONFIG_UFSFBO)
+	if (ufsfbo_get_state(ufsf) == FBO_RESET)
+		ufsfbo_reset(ufsf);
+#endif
 }
 
 inline void ufsf_remove(struct ufsf_feature *ufsf)
@@ -542,6 +614,10 @@ inline void ufsf_remove(struct ufsf_feature *ufsf)
 	if (ufsf->sid_dev)
 		ufssid_remove(ufsf);
 #endif
+#if defined(CONFIG_UFSFBO)
+	if (ufsfbo_get_state(ufsf) == FBO_PRESENT)
+		ufsfbo_remove(ufsf);
+#endif
 }
 
 static void ufsf_device_check_work_handler(struct work_struct *work)
@@ -641,6 +717,9 @@ inline void ufsf_set_init_state(struct ufs_hba *hba)
 	INIT_WORK(&ufsf->on_idle_work, ufsf_on_idle);
 	ufshid_set_state(ufsf, HID_NEED_INIT);
 #endif
+#if defined(CONFIG_UFSFBO)
+	ufsfbo_set_state(ufsf, FBO_NEED_INIT);
+#endif
 }
 
 inline void ufsf_suspend(struct ufsf_feature *ufsf)
@@ -658,6 +737,11 @@ inline void ufsf_suspend(struct ufsf_feature *ufsf)
 	if (ufshid_get_state(ufsf) == HID_PRESENT)
 		ufshid_suspend(ufsf);
 #endif
+
+#if defined(CONFIG_UFSFBO)
+	if (ufsfbo_get_state(ufsf) == FBO_PRESENT)
+		ufsfbo_suspend(ufsf);
+#endif
 }
 
 inline void ufsf_resume(struct ufsf_feature *ufsf, bool is_link_off)
@@ -666,6 +750,11 @@ inline void ufsf_resume(struct ufsf_feature *ufsf, bool is_link_off)
 	if (ufshid_get_state(ufsf) == HID_SUSPEND)
 		ufshid_resume(ufsf);
 #endif
+#if defined(CONFIG_UFSFBO)
+	if (ufsfbo_get_state(ufsf) == FBO_SUSPEND) {
+		ufsfbo_resume(ufsf, is_link_off);
+	}
+#endif
 }
 
 inline void ufsf_change_lun(struct ufsf_feature *ufsf,
diff --git a/drivers/scsi/ufs/vendor/ufsfeature.h b/drivers/scsi/ufs/vendor/ufsfeature.h
index a51c706d85cc..92df8c4c8524 100644
--- a/drivers/scsi/ufs/vendor/ufsfeature.h
+++ b/drivers/scsi/ufs/vendor/ufsfeature.h
@@ -45,6 +45,7 @@
 
 #include "ufshid.h"
 #include "ufssid.h"
+#include "ufsfbo.h"
 
 #define UFS_UPIU_MAX_GENERAL_LUN		8
 
@@ -93,11 +94,13 @@ enum {
 #define UFSF_QUERY_DESC_DEVICE_MAX_SIZE		0xFF
 #define UFSF_QUERY_DESC_CONFIGURAION_MAX_SIZE	0xE6
 #define UFSF_QUERY_DESC_GEOMETRY_MAX_SIZE	0xFE
+#define UFSF_QUERY_DESC_FBO_MAX_SIZE		0x12
 
 /* Descriptor idn for Query Request */
 #define UFSF_QUERY_DESC_IDN_DEVICE		0xF0
 #define UFSF_QUERY_DESC_IDN_GEOMETRY		0xF7
 
+#define UFSF_QUERY_DESC_IDN_FBO			0x0A
 /* query_flag  */
 #define MASK_QUERY_UPIU_FLAG_LOC		0xFF
 
@@ -141,12 +144,19 @@ struct ufsf_feature {
 #if defined(CONFIG_UFSSID)
 	struct ufssid_dev *sid_dev;
 #endif
+
+#if defined(CONFIG_UFSFBO)
+	atomic_t fbo_state;
+	struct ufsfbo_dev *fbo_dev;
+#endif
+
 };
 
 struct ufs_hba;
 struct ufshcd_lrb;
 struct ufs_ioctl_query_data;
 
+inline int is_vendor_device(struct ufs_hba *hba, int id);
 void ufsf_device_check(struct ufs_hba *hba);
 int ufsf_query_ioctl(struct ufsf_feature *ufsf, int lun, void __user *buffer,
 		     struct ufs_ioctl_query_data *ioctl_data);
@@ -202,6 +212,11 @@ void ufsf_hid_acc_io_stat(struct ufsf_feature *ufsf, struct ufshcd_lrb *lrbp);
 #define GEOMETRY_DESC_HID_MAX_LBA_RANGE_SIZE		0xF9
 #endif
 
+#if defined(CONFIG_UFSFBO)
+#define QUERY_ATTR_IDN_FBO_CONTROL			0x31
+#define QUERY_ATTR_IDN_FBO_EXECUTE_THRESHOLD		0x32
+#define QUERY_ATTR_IDN_FBO_PROGRESS_STATE		0x33
+#endif
 /**
  * struct utp_upiu_task_req - Task request UPIU structure
  * @header - UPIU header structure DW0 to DW-2
@@ -218,6 +233,18 @@ struct utp_upiu_task_req {
 	__be32 reserved[2];
 };
 
+#if defined(CONFIG_UFSFBO)
+/* File Based Optimization (FBO) descriptor parameters offsets in bytes */
+enum fbo_desc_param {
+	FBO_DESC_PARAM_LEN				= 0x0,
+	FBO_DESC_PARAM_FBO_VERSION			= 0x1,
+	FBO_DESC_PARAM_FBO_RECOMMENDED_LBA_RANGE_SIZE	= 0x3,
+	FBO_DESC_PARAM_FBO_MAX_LBA_RANGE_SIZE		= 0x7,
+	FBO_DESC_PARAM_FBO_MIN_LBA_RANGE_SIZE		= 0xB,
+	FBO_DESC_PARAM_FBO_MAX_LBA_RANGE_COUNT		= 0xF,
+	FBO_DESC_PARAM_FBO_LBA_RANGE_ALIGNMENT		= 0x10,
+};
+#endif
 static inline int ufsf_check_query(__u32 opcode)
 {
 	return (opcode & 0xffff0000) >> 16 == UFSFEATURE_QUERY_OPCODE;
